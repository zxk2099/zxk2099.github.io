<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Unity11 - Java快速入门</title>
    <link href="/2024/02/17/Unity11%20-%20Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2024/02/17/Unity11%20-%20Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>在<code>C#</code>基础上快速入门<code>Java</code></p><span id="more"></span><!-- omit in toc --><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#%E5%8F%98%E9%87%8F">变量</a></li><li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></li><li><a href="#%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF">条件分支</a></li><li><a href="#%E5%BE%AA%E7%8E%AF">循环</a></li><li><a href="#%E6%95%B0%E7%BB%84">数组</a><ul><li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">二维数组</a></li><li><a href="#%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84">交错数组</a></li><li><a href="#arrays%E7%B1%BB-%E4%B8%93%E9%97%A8%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84javautilarrays"><code>Arrays</code>类: 专门操作数组(<code>java.util.Arrays</code>)</a></li></ul></li><li><a href="#%E5%87%BD%E6%95%B0">函数</a></li><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a><ul><li><a href="#%E5%B0%81%E8%A3%85">封装</a></li><li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li><li><a href="#%E5%A4%9A%E6%80%81">多态</a></li></ul></li><li><a href="#%E5%8C%85package-%E7%B1%BB%E4%BC%BCc%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4namespace">包<code>package</code>: 类似<code>C#</code>中的命名空间<code>namespace</code></a><ul><li><a href="#%E5%8C%85%E5%90%8D%E8%A7%84%E5%88%99">包名规则</a></li><li><a href="#%E6%96%B0%E5%BB%BA%E5%8C%85">新建包</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%8C%85">使用包</a></li><li><a href="#%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5-%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%BD%BF%E7%94%A8">静态导入: 作为静态成员使用</a></li></ul></li><li><a href="#%E5%86%85%E9%83%A8%E7%B1%BB">内部类</a><ul><li><a href="#%E9%9D%9E%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">非匿名内部类</a></li><li><a href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E8%BE%83%E5%B0%91%E7%94%A8">匿名内部类(较少用)</a></li></ul></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C">字符串操作</a><ul><li><a href="#string"><code>String</code></a></li><li><a href="#stringbuilder"><code>StringBuilder</code></a></li></ul></li><li><a href="#%E9%9B%86%E5%90%88%E7%B1%BB">集合类</a><ul><li><a href="#%E6%B3%9B%E5%9E%8B">泛型</a></li><li><a href="#arraylist%E5%92%8Clinkedlist%E7%B1%BB%E4%BC%BCc%E7%9A%84list%E5%92%8Clinkedlist"><code>ArrayList</code>和<code>LinkedList</code>(类似<code>C#</code>的<code>List</code>和<code>LinkedList</code>)</a></li><li><a href="#hashset%E5%92%8Ctreeset"><code>HashSet</code>和<code>TreeSet</code></a></li><li><a href="#hashmap%E5%92%8Ctreemap"><code>HashMap</code>和<code>TreeMap</code></a></li></ul></li><li><a href="#%E5%85%B6%E4%BB%96%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9%E5%81%9A%E4%BA%86%E8%A7%A3">其他不常用内容做了解</a><ul><li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E5%9F%BA%E6%9C%AC%E5%90%8Cc">异常处理: 基本同<code>C#</code></a></li><li><a href="#lambda"><code>lambda</code></a></li><li><a href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8Cfunction-%E7%94%A8%E5%87%BD%E6%95%B0%E8%A3%85%E8%BD%BD%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-%E7%B1%BB%E4%BC%BCc%E5%A7%94%E6%89%98">方法的引用和<code>Function</code>: 用函数装载函数式接口, 类似<code>C#</code>委托</a></li><li><a href="#%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93">常用类库</a><ul><li><a href="#number-%E6%89%80%E6%9C%89%E6%95%B0%E7%9A%84%E7%88%B6%E7%B1%BB"><code>Number</code>: 所有数的父类</a></li><li><a href="#biginteger-%E5%AD%98%E5%82%A8%E4%BB%BB%E6%84%8F%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%95%B4%E6%95%B0"><code>BigInteger</code>: 存储任意大小的整数</a></li><li><a href="#bigdecimal-%E5%AD%98%E5%82%A8%E5%A4%A7%E6%B5%AE%E7%82%B9%E6%95%B0"><code>BigDecimal</code>: 存储大浮点数</a></li><li><a href="#math-%E9%9D%99%E6%80%81%E7%B1%BB"><code>Math</code>: 静态类</a></li><li><a href="#date%E6%97%A5%E6%9C%9F%E7%B1%BB-system%E7%B3%BB%E7%BB%9F%E7%B1%BB"><code>Date</code>日期类, <code>System</code>系统类</a></li></ul></li></ul></li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a><a href="#%E7%9B%AE%E5%BD%95">变量</a></h1><ul><li><code>Java</code>中没有专门的无符号类型</li><li>常量是<code>final</code></li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><a href="#%E7%9B%AE%E5%BD%95">运算符</a></h1><p>同<code>C#</code></p><h1 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a><a href="#%E7%9B%AE%E5%BD%95">条件分支</a></h1><ul><li><code>if</code>: 同<code>C#</code></li><li><code>switch</code>: 贯穿时可以加入逻辑语句, 其他同<code>C#</code><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//C#</span><br><span class="hljs-comment">//一个int i</span><br><span class="hljs-keyword">switch</span> (i)<br>&#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">/*贯穿时case 1不允许有代码*/</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      Console.WriteLine(i);<br>      <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//Java</span><br><span class="hljs-comment">//一个int i</span><br><span class="hljs-keyword">switch</span>(i)<br>&#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">/*case 1中允许有自己单独的逻辑语句再贯穿*/</span><br>      i++;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      System.out.println(i);<br>      <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a><a href="#%E7%9B%AE%E5%BD%95">循环</a></h1><ul><li><code>while</code>同<code>C#</code></li><li><code>do &#123;&#125; while()</code>同<code>C#</code></li><li><code>for</code>同<code>C#</code></li><li><code>foreach</code>: 使用同名<code>for</code>, 使用<code>:</code>替换<code>in</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : arr)&#123;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>break</code>&#x2F;<code>continue</code>: 同<code>C#</code></li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a><a href="#%E7%9B%AE%E5%BD%95">数组</a></h1><ul><li>声明方式多了一种: <ul><li><code>int[] arr;</code></li><li><code>int arr[];</code></li></ul></li></ul><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ul><li><code>Java</code>的二维数组与<code>C#</code>的交错数组写法一致: <code>int[][] arr</code></li></ul><h2 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h2><ul><li><code>int[][] arr = new int[n][]</code></li></ul><h2 id="Arrays类-专门操作数组-java-util-Arrays"><a href="#Arrays类-专门操作数组-java-util-Arrays" class="headerlink" title="Arrays类: 专门操作数组(java.util.Arrays)"></a><code>Arrays</code>类: 专门操作数组(<code>java.util.Arrays</code>)</h2><ul><li>使用一个值填充数组: <code>fill</code><ul><li><code>Arrays.fill(数组,填充值)</code></li><li><code>Arrays.fill(数组,填充起始位置,填充最后位置,填充值)</code></li></ul></li><li>排序: <code>sort</code></li><li>复制数组: <code>copyOf</code><ul><li><code>Arrays.copyOf(被复制数组, 复制长度)</code></li></ul></li><li>复制数组特定范围: <code>copyOfRange</code><ul><li><code>Arrays.copyOfRange(被复制数组,起始位置,最后位置(不包括))</code></li></ul></li><li>二分法查询数组: <code>binarySearch</code>(使用前必须先排序)<ul><li><code>Arrays.binarySearch(数组,元素)</code></li><li><code>Arrays.binarySearch(数组,起始搜索位置,最后搜索位置(不包括),元素)</code></li></ul></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a><a href="#%E7%9B%AE%E5%BD%95">函数</a></h1><ul><li><code>java</code>函数没有<code>ref</code>和<code>out</code></li><li><code>java</code>函数的可变参数写法与<code>C#</code>不同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String... strs)</span>&#123;<br>  <span class="hljs-comment">/*按String[]使用*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>java</code>函数没有默认参数的说法</li><li><code>java</code>函数一般驼峰命名法(第一个小写,第二个单词开始大写)</li></ul><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><a href="#%E7%9B%AE%E5%BD%95">面向对象</a></h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li>声明<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名<br>&#123;<br>  <span class="hljs-comment">//成员变量</span><br>  <span class="hljs-comment">//成员方法</span><br>  <span class="hljs-comment">//构造函数</span><br>  <span class="hljs-comment">//finalize函数</span><br>  <span class="hljs-comment">//静态函数</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>与<code>C#</code>的不同<ul><li>没有成员属性, 但有可以对成员变量自动生成<code>get</code>,<code>set</code>方法</li><li>没有析构函数, 但有类似的<code>finalize</code>函数<blockquote><p>主动垃圾回收: <code>System.gc();</code></p></blockquote></li><li>没有索引器</li><li>没有运算符重载</li></ul></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>与<code>C#</code>的相同<ul><li>类与类只能单继承</li><li>万物之父<code>Object</code>类</li><li>遵循里氏替换</li></ul></li><li>继承关键字: <code>extends</code>替代<code>C#</code>中的<code>:</code></li><li><code>Object</code>类的一些方法<ul><li><code>getClass()</code>: 类似<code>C#</code>的<code>getType()</code></li><li><code>toString()</code></li><li><code>equals()</code><blockquote><p><code>equals</code>比较两个对象的内容是否相等, <code>==</code>比较两个对象的引用地址是否相同</p></blockquote></li></ul></li><li><code>instanceof</code>判断类型, 类似<code>C#</code>中的<code>is</code><blockquote><p>没有<code>as</code>, 只能用括号强转</p></blockquote></li><li><code>final</code>的作用<ul><li>禁止变量的修改 &#x3D;&gt; 成为常量</li><li>禁止函数的重写</li><li>禁止类的继承</li></ul></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li><code>Java</code>中没有<code>VOB</code><ul><li>没有<code>virtual</code>&#x2F;<code>override</code>关键字, 重写时直接实现同名方法就可以覆盖父类方法, 使用<code>super</code>调用父类(类似<code>base</code>)<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//C#里氏替换后默认调用父类方法</span><br>Father s = <span class="hljs-keyword">new</span> Son();<br>s.Eat(); <span class="hljs-comment">//父亲吃</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java里氏替换后直接调用子类方法(如果重写了)</span><br><span class="hljs-type">Father</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>s.eat(); <span class="hljs-comment">//子吃</span><br></code></pre></td></tr></table></figure></li><li><code>java</code>会自动补一个<code>@override</code>, 注释作用, 可有可无</li></ul></li><li>抽象类和抽象方法<code>abstract</code>: 同<code>C#</code></li><li>接口<ul><li>默认只能<code>public</code></li><li>字段只能是静态常量<code>static final</code></li><li>关键字<code>implements</code>, 用逗号<code>,</code>分隔多个接口</li><li>没有显式实现接口: 多个接口有同名方法时, 重写的方法所有接口共享<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//C#: 多个接口具有同名方法时, 必须显式实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleClass</span> : <span class="hljs-title">IControl</span>, <span class="hljs-title">ISurface</span><br>&#123;<br>    <span class="hljs-keyword">void</span> IControl.Paint()<br>    &#123;<br>        System.Console.WriteLine(<span class="hljs-string">&quot;IControl.Paint&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> ISurface.Paint()<br>    &#123;<br>        System.Console.WriteLine(<span class="hljs-string">&quot;ISurface.Paint&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//C#: 对象不可直接使用, 需要用接口装一次用对应接口使用</span><br>SampleClass sample = <span class="hljs-keyword">new</span> SampleClass();<br>IControl control = sample;<br>control.Paint();<br><span class="hljs-comment">//C#: 或使用as</span><br>(sample <span class="hljs-keyword">as</span> IControl).Paint();<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="包package-类似C-中的命名空间namespace"><a href="#包package-类似C-中的命名空间namespace" class="headerlink" title="包package: 类似C#中的命名空间namespace"></a><a href="#%E7%9B%AE%E5%BD%95">包<code>package</code>: 类似<code>C#</code>中的命名空间<code>namespace</code></a></h1><h2 id="包名规则"><a href="#包名规则" class="headerlink" title="包名规则"></a>包名规则</h2><ul><li>多人完成, 版权归属发起者: <code>indi.发起者名.项目名.模块名</code></li><li>独立完成, 公开, 版权归属个人: <code>pers.个人名.项目名.模块名</code></li><li>独立完成, 非公开, 版权归属个人: <code>priv.个人名.项目名.模块名</code></li><li>团队研发, 版权归属团队: <code>team.团队名.项目名.模块名</code></li><li>公司研发, 版权归属公司: <code>com.公司名.项目名.模块名</code></li></ul><h2 id="新建包"><a href="#新建包" class="headerlink" title="新建包"></a>新建包</h2><ul><li>包的本质是文件夹, <code>class</code>类是文件夹中的<code>.java</code>文件</li><li>需要在文件夹内新建包, 对应的<code>.java</code>文件头部需要注明包名<code>package 完整包名;</code></li></ul><h2 id="使用包"><a href="#使用包" class="headerlink" title="使用包"></a>使用包</h2><ul><li>关键字: <code>import</code>, 类似<code>using</code></li><li><code>import</code>的对象必须是特定的<code>.java</code>文件, 即必须引用到具体的<code>class</code>, 如果引用包中有多个<code>.java</code>文件则使用<code>包名.*</code>引入全部, 或仅引入特定几个<ul><li><code>.java</code>文件&#x2F;<code>class</code>以大写字幕开头, 文件夹&#x2F;<code>package</code>是小写字母</li></ul></li></ul><h2 id="静态导入-作为静态成员使用"><a href="#静态导入-作为静态成员使用" class="headerlink" title="静态导入: 作为静态成员使用"></a>静态导入: 作为静态成员使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//不导入包</span><br>System.out.println(<span class="hljs-string">&quot;不导入包&quot;</span>);<br><br><span class="hljs-comment">//静态导入所有成员</span><br><span class="hljs-keyword">import</span> java.lang.System.*;<br>out.println(<span class="hljs-string">&quot;a&quot;</span>);<br><br><span class="hljs-comment">//静态导入特定成员</span><br><span class="hljs-keyword">import</span> java.lang.System.out;<br>println(<span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a><a href="#%E7%9B%AE%E5%BD%95">内部类</a></h1><h2 id="非匿名内部类"><a href="#非匿名内部类" class="headerlink" title="非匿名内部类"></a>非匿名内部类</h2><ul><li>声明与<code>C#</code>相同, 使用不同: <code>java</code>内部类在外部的实例化必须依赖外部类对象<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//C#声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span><br>&#123;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span><br>  &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">//C#使用</span><br>Outer.Inner i = <span class="hljs-keyword">new</span> Outer.Inner();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span><br>&#123;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span><br>  &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">//java使用</span><br><span class="hljs-type">Outer</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">o</span>.Inner();<br></code></pre></td></tr></table></figure></li><li>外部类的所有成员(包括<code>private</code>)都可以直接供内部类使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//同名变量层级: 就近原则</span><br><span class="hljs-keyword">import</span> java.lang.System.out;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span><br>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> ;<br><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span><br>  &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span><br>      &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>          println(i); <span class="hljs-comment">//3</span><br>          println(<span class="hljs-built_in">this</span>.i); <span class="hljs-comment">//2</span><br>          println(Outer.<span class="hljs-built_in">this</span>.i); <span class="hljs-comment">//1</span><br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="匿名内部类-较少用"><a href="#匿名内部类-较少用" class="headerlink" title="匿名内部类(较少用)"></a>匿名内部类(较少用)</h2><ul><li>类似继承与重写<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span><br>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-type">Outer</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>()&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span><br>  &#123;<br>      <span class="hljs-comment">/*自己的逻辑*/</span><br>  &#125;<br>&#125;;<br>o.Test(); <span class="hljs-comment">//自己的逻辑</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a><a href="#%E7%9B%AE%E5%BD%95">字符串操作</a></h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h2><ul><li>声明时直接赋值则存储在公共内存池, 使用<code>new</code>则主动划分一块区域<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-comment">//以上两个变量指向同一个地址</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-comment">//以上两个变量指向两个区域</span><br></code></pre></td></tr></table></figure></li><li>拼接: 同<code>C#</code>, 生成新<code>String</code></li><li>常用方法<ul><li>判断相同: <code>equals</code>&#x2F;<code>equalsIgnoreCase</code><blockquote><p>❗❗❗<code>==</code>判断引用地址, 因此只能用<code>equals</code></p></blockquote></li><li>长度: <code>length()</code><blockquote><p>❗❗❗<code>java</code>中没有属性, 只有方法和变量(的<code>getter</code>和<code>setter</code>), 要获得对象的特定变量值, 要么使用对应的方法, 要么用对应的<code>getter</code></p></blockquote></li><li>正反向查找: <code>indexOf(String s)</code>&#x2F;<code>lastIndexOf(String s)</code>, 无则<code>-1</code></li><li>指定位置字符: <code>charAt(int i)</code></li><li>取中间文本: <code>substring(起始index,[结尾index(不包含)])</code></li><li>去除首尾空格: <code>trim()</code></li><li>字符替换: <code>replace(char 原, char 新)</code></li><li>判断开头和结尾: <code>startsWith(String s)</code>&#x2F;<code>endsWith(String s)</code></li><li>大小写转换: <code>toLowerCase()</code>&#x2F;<code>toUpperCase()</code></li><li>字符串分割: <code>split(String sign)</code></li><li>字符串格式化: <code>format(文本,数据...)</code><ul><li><code>%tF</code>: 年-月-日</li><li><code>%tD</code>: 月&#x2F;日&#x2F;年</li><li><code>%tr</code>: 时:分:秒 12h</li><li><code>%tT</code>: 时:分:秒 24h</li><li><code>%tR</code>: 时:分 24h</li></ul></li></ul></li></ul><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a><code>StringBuilder</code></h2><ul><li>拼接: <code>append(内容)</code></li><li>插入: <code>insert(位置,内容)</code></li><li>删除: <code>delete(起始位置, 结尾位置(不包含))</code></li><li>转<code>String</code>: <code>toString()</code></li></ul><h1 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a><a href="#%E7%9B%AE%E5%BD%95">集合类</a></h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型类的声明同`C#`一样, 调用时需要使用包装类而不是变量类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;T&gt;&#123;&#125;<br>Test&lt;Integer&gt; t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;();<br>  <span class="hljs-comment">//约束在&lt;&gt;中extends, 类或接口都是</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Test</span>&gt;&#123;&#125;<br>  <span class="hljs-comment">//泛型通配符?表示暂时不确定什么类型, 实例化时才确定, 可以extends</span><br>  Test&lt;?&gt; t = <span class="hljs-literal">null</span>;<br>  t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br><br><span class="hljs-comment">//泛型函数的声明需要写在访问修饰符后, 调用时直接调用</span><br><span class="hljs-keyword">public</span>&lt;K&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">Fun</span><span class="hljs-params">(K k)</span>&#123;&#125;<br>Fun(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><h2 id="ArrayList和LinkedList-类似C-的List和LinkedList"><a href="#ArrayList和LinkedList-类似C-的List和LinkedList" class="headerlink" title="ArrayList和LinkedList(类似C#的List和LinkedList)"></a><code>ArrayList</code>和<code>LinkedList</code>(类似<code>C#</code>的<code>List</code>和<code>LinkedList</code>)</h2><ul><li><code>ArrayList</code>和<code>LinkedList</code>都实现了<code>List</code>接口, <code>List</code>接口实现了<code>Collection</code>接口</li><li><code>ArrayList</code>和<code>LinkedList</code>具有相同的调用方法, 使用完全一致, 区别在于前者的本质是顺序存储的数组, 后者的本质是链式存储的链表</li><li><code>Collection</code>接口方法<ul><li><code>add()</code></li><li><code>remove()</code></li><li><code>clear()</code></li><li><code>isEmpty()</code></li><li><code>iterator()</code>: 获取迭代器, 用于遍历</li><li><code>size()</code></li><li><code>contains()</code></li><li><code>toArray()</code>将容器中的元素转为数组</li></ul></li><li><code>List</code>接口方法<ul><li><code>get(int index)</code></li><li><code>set(int index, object obj)</code></li></ul></li><li><code>ArrayList</code>和<code>LinkedList</code>使用<ul><li>声明: <code>ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();</code></li><li>增: <code>list.add(T t);</code></li><li>删: <code>list.remove(int index);</code>&#x2F;<code>list.remove(T t)</code>&#x2F;<code>list.clear();</code><ul><li>可以传入<code>int索引</code>或<code>元素</code>, 如果元素是<code>int</code>则只能传索引</li><li>删除后后面的元素往前移动占位</li></ul></li><li>查: <code>list.get(int index)</code>&#x2F;<code>list.contains(T t)</code></li><li>改: <code>list.set(int index, T t)</code></li><li>遍历: <code>for</code>&#x2F;<code>for:</code>&#x2F;<code>Iterator</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;T t&gt; it = list.iterator(); <span class="hljs-comment">//Iterator泛型必须与list相同</span><br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    println(it.next());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="HashSet和TreeSet"><a href="#HashSet和TreeSet" class="headerlink" title="HashSet和TreeSet"></a><code>HashSet</code>和<code>TreeSet</code></h2><pre><code class=" mermaid">classDiagramdirection LRclass Collection&#123; &lt;&lt;interface&gt;&gt;&#125;class Set&#123; &lt;&lt;interface&gt;&gt;&#125;class HashSetclass SortedSetclass TreeSetCollection &lt;|.. Set:实现Set &lt;|.. HashSet:实现Set &lt;|.. SortedSet:实现SortedSet &lt;|-- TreeSet:继承</code></pre><ul><li>相同点<ul><li>不允许重复元素, <code>ArrayList</code>和<code>LinkedList</code>允许重复</li><li>不能索引查改</li></ul></li><li>不同<table><thead><tr><th></th><th><code>HashSet</code></th><th><code>TreeSet</code></th></tr></thead><tbody><tr><td>底层数据结构</td><td>哈希表</td><td>树</td></tr><tr><td>排列顺序</td><td>不一定有序</td><td>自动排序</td></tr></tbody></table><blockquote><p><code>TreeSet</code>的自动排序: 元素是数字时按大小排序, <code>String</code>按字符编码升序, 自定义类时需要实现<code>Comparable</code>接口重载排序方法</p></blockquote></li><li><code>HashSet</code>和<code>TreeSet</code>使用<ul><li>声明: <code>HashSet&lt;T t&gt; h = new HashSet&lt;&gt;()</code></li><li>增: <code>h.add(T t)</code></li><li>删: <code>h.remove(T t)</code> 无法使用索引</li><li>查: <code>h.contains(T t)</code></li><li>没有改</li><li>遍历: <code>for:</code>&#x2F;<code>Iterator</code></li></ul></li><li><code>TreeSet</code>独有方法<ul><li>返回<u>第一个&#x2F;最后一个</u>元素: <code>first()</code>&#x2F;<code>last()</code></li><li>取出<u>第一个&#x2F;最后一个</u>元素: <code>pollFirst()</code>&#x2F;<code>pollLast()</code></li><li>取中间元素的集合: <code>subSet(T tStart, T sEnd)</code>(含左不含右)</li><li>取<u>头部&#x2F;尾部</u>元素的集合: <code>headSet(T t)</code>&#x2F;<code>tailSet(T t)</code></li></ul></li></ul><h2 id="HashMap和TreeMap"><a href="#HashMap和TreeMap" class="headerlink" title="HashMap和TreeMap"></a><code>HashMap</code>和<code>TreeMap</code></h2><pre><code class=" mermaid">classDiagramdirection LRclass Map&#123; &lt;&lt;interface&gt;&gt;&#125;class HashMapclass TreeMapMap &lt;|.. HashMap:实现Map &lt;|.. TreeMap:实现</code></pre><ul><li><code>Map</code>方法<ul><li>添加: <code>put(K key,V value)</code></li><li>是否存在: <code>containsKey(Object key)</code>&#x2F;<code>containsValue(Object value)</code></li><li>获取<code>key</code>的值: <code>get(Object key)</code> 没有<code>key</code>返回<code>null</code></li><li>所有<code>key</code>形成的<code>Set</code>: <code>keySet()</code></li><li>所有<code>value</code>形成的<code>Collection</code>: <code>values()</code></li><li>键值对对数: <code>size()</code></li><li>是否为空: <code>isEmpty()</code></li><li>移除by <code>key</code>: <code>remove(Object key)</code></li><li>清空: <code>clear()</code></li></ul></li><li><code>HashMap</code>和<code>TreeMap</code>相同点: 使用键值对存储数据, 方法基本相同</li><li><code>HashMap</code>和<code>TreeMap</code>不同<table><thead><tr><th></th><th><code>HashMap</code></th><th><code>TreeMap</code></th></tr></thead><tbody><tr><td>关于<code>null</code></td><td>允许<code>null</code>键和<code>null</code>值<br>(但必须保证键的唯一性)</td><td>不允许<code>null</code>键</td></tr><tr><td>数据存储顺序</td><td></td><td>内部会排序, 添加&#x2F;删除&#x2F;定位时效率较差</td></tr><tr><td>数据结构</td><td>基于哈希表</td><td>基于树</td></tr></tbody></table><blockquote><p>一般都使用<code>HashMap</code>, 除非需要排序时才使用<code>TreeMap</code></p></blockquote></li><li><code>HashMap</code>和<code>TreeMap</code>使用<ul><li>声明: <code>HashMap&lt;K k, V v&gt; m = new HashMap&lt;&gt;()</code></li><li>增&#x2F;改: <code>m.put(K k, V v)</code></li><li>删: <code>m.remove(K k)</code></li><li>查: <code>m.get(K k)</code>&#x2F;<code>m.containsKey(K k)</code>&#x2F;<code>m.containsValue(V v)</code></li></ul></li></ul><h1 id="其他不常用内容做了解"><a href="#其他不常用内容做了解" class="headerlink" title="其他不常用内容做了解"></a><a href="#%E7%9B%AE%E5%BD%95">其他不常用内容做了解</a></h1><h2 id="异常处理-基本同C"><a href="#异常处理-基本同C" class="headerlink" title="异常处理: 基本同C#"></a>异常处理: 基本同<code>C#</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;&#125;<br><span class="hljs-keyword">catch</span> (Exception ex) &#123;&#125;<br><span class="hljs-keyword">finally</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a><code>lambda</code></h2><ul><li>基本结构: <code>(参数)-&gt;&#123;代码&#125;</code> 只有一行代码时省略<code>&#123;&#125;</code></li><li>函数式接口声明<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITest</span>&#123; <span class="hljs-comment">//一个空接口</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>; <span class="hljs-comment">//一个空函数</span><br>&#125;<br><br><span class="hljs-type">ITest</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> ()-&gt;&#123; <span class="hljs-comment">//对函数式接口中函数的lambda实现</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>  <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>&#125;<br><br>t.Test(); <span class="hljs-comment">//调用</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="方法的引用和Function-用函数装载函数式接口-类似C-委托"><a href="#方法的引用和Function-用函数装载函数式接口-类似C-委托" class="headerlink" title="方法的引用和Function: 用函数装载函数式接口, 类似C#委托"></a>方法的引用和<code>Function</code>: 用函数装载函数式接口, 类似<code>C#</code>委托</h2><ul><li>原理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITest</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITest2</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> Test <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITest3</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> Test <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITest4</span>&lt;T&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> Test <span class="hljs-title function_">fun</span><span class="hljs-params">(T t)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span>&lt;T&gt; <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">FX</span><span class="hljs-params">(T t)</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">//1.静态方法</span><br><span class="hljs-type">ITest</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> Test::Add;<br>t1.Test(); <span class="hljs-comment">//等于Test.Add();</span><br><br><span class="hljs-comment">//2.成员方法</span><br><span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br><span class="hljs-type">ITest</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> t::Add();<br>t2.Test(); <span class="hljs-comment">//等于t.Add();</span><br><br><span class="hljs-comment">//3.构造</span><br><span class="hljs-type">ITest2</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> Test::<span class="hljs-keyword">new</span>;<br><span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> t3.fun(); <span class="hljs-comment">//无参构造Test, 等于new Test()</span><br><br><span class="hljs-type">ITest3</span> <span class="hljs-variable">t4</span> <span class="hljs-operator">=</span> Test::<span class="hljs-keyword">new</span>;<br><span class="hljs-type">Test</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> t4.fun(<span class="hljs-number">5</span>); <span class="hljs-comment">//有参构造Test, 等于new Test(5)</span><br><br><span class="hljs-comment">//4.泛型</span><br>ITest4&lt;Integer&gt; t5 = Test::FX;<br>t5.fun(<span class="hljs-number">55</span>); <span class="hljs-comment">//等于Test.FX(55);</span><br></code></pre></td></tr></table></figure></li><li>封装: <code>Function&lt;T,R&gt;</code>接口, <code>T</code>是参数,<code>R</code>是返回值, 调用方法<code>apply</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;Integer,String&gt; f = (i)-&gt;&#123; <span class="hljs-keyword">return</span> (i+<span class="hljs-number">1</span>).toString();&#125;;<br>f.apply(<span class="hljs-number">5</span>); <span class="hljs-comment">//6</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="常用类库"><a href="#常用类库" class="headerlink" title="常用类库"></a>常用类库</h2><ul><li>基本变量类型包装类: <code>Integer</code>,<code>Boolean</code>,<code>Double</code>,<code>Character</code>,<code>Number</code>等</li><li>较大数据<code>BigInteger</code>,<code>BigDecimal</code></li><li>数学计算类<code>Math</code></li><li>随机数类<code>Random</code></li></ul><h3 id="Number-所有数的父类"><a href="#Number-所有数的父类" class="headerlink" title="Number: 所有数的父类"></a><code>Number</code>: 所有数的父类</h3><ul><li><code>byteValue()</code>以<code>byte</code>形式返回数值</li><li><code>intValue</code>&#x2F;<code>floatValue</code>等等</li></ul><h3 id="BigInteger-存储任意大小的整数"><a href="#BigInteger-存储任意大小的整数" class="headerlink" title="BigInteger: 存储任意大小的整数"></a><code>BigInteger</code>: 存储任意大小的整数</h3><ul><li>使用<code>add</code>,<code>subtract</code>等方法运算, 不能用运算符运算</li></ul><h3 id="BigDecimal-存储大浮点数"><a href="#BigDecimal-存储大浮点数" class="headerlink" title="BigDecimal: 存储大浮点数"></a><code>BigDecimal</code>: 存储大浮点数</h3><h3 id="Math-静态类"><a href="#Math-静态类" class="headerlink" title="Math: 静态类"></a><code>Math</code>: 静态类</h3><h3 id="Date日期类-System系统类"><a href="#Date日期类-System系统类" class="headerlink" title="Date日期类, System系统类"></a><code>Date</code>日期类, <code>System</code>系统类</h3>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我家里新开了个饭店，很多客人结账时要求抹零，该怎么解决这种问题？</title>
    <link href="/2024/02/14/%E6%88%91%E5%AE%B6%E9%87%8C%E6%96%B0%E5%BC%80%E4%BA%86%E4%B8%AA%E9%A5%AD%E5%BA%97%EF%BC%8C%E5%BE%88%E5%A4%9A%E5%AE%A2%E4%BA%BA%E7%BB%93%E8%B4%A6%E6%97%B6%E8%A6%81%E6%B1%82%E6%8A%B9%E9%9B%B6%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E7%A7%8D%E9%97%AE%E9%A2%98%EF%BC%9F/"/>
    <url>/2024/02/14/%E6%88%91%E5%AE%B6%E9%87%8C%E6%96%B0%E5%BC%80%E4%BA%86%E4%B8%AA%E9%A5%AD%E5%BA%97%EF%BC%8C%E5%BE%88%E5%A4%9A%E5%AE%A2%E4%BA%BA%E7%BB%93%E8%B4%A6%E6%97%B6%E8%A6%81%E6%B1%82%E6%8A%B9%E9%9B%B6%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E7%A7%8D%E9%97%AE%E9%A2%98%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>抹零与定价：<br>抹零以提高回头率；定价以8、9结尾便于实现抹零；以小于4定价的商品为可以白送的添头。<br></p><span id="more"></span><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这个问题其实非常有意思，答案是 <strong>尽量把菜单里常点菜的单价尾数设成8或者9</strong><br><br>也就是说一盘菜38、48、58或者39、49、59……<br><br>这还得从十多年前暑假我在姑姑家饭店打零工说起<br><br>当时饭店小本经营，饭店里10个四人小桌，两个小包间，<br><br>一桌饭四个人100块钱左右，<br><br>当时我姑父特别喜欢<strong>抹零头，一般100以下就是抹5块（四舍五不入），100以上的抹10块（个位抹掉），</strong>而且是主动抹零头，以招揽顾客。如此经营，饭店的口碑还真是便宜实惠，且生意兴隆。<br><br>年轻的我就问：“这么抹零头不亏么？”<br><br>姑父：“都包在里面了，能吃亏么？”<br><br>我说：“那不也少赚了么？”<br><br>姑父：“少赚不了多少，还能多招回头客。”<br><br>我表示不懂。<br><br>姑父：“看看菜单，是不是都是28、38的？”<br><br>我依然表示不明白。<br><br>姑父：“这样<strong>他点一个菜或者两个菜，没法抹零，如果点三、四个菜，我最多就抹5块钱</strong>，也不亏，还能落个好。”<br><br>我表示依然不懂。<br><br>姑父：“你要把单价都设成22或者32的，你点俩菜，是不是我就得给你抹了？”<br><br>我好像懂点了，姑父说：“8或者9都行……”<br><br>我说：“那100块以上的抹十块不亏了么？”<br><br>姑父：“100块以上得点5个菜以上，最多抹10块，还是赚”<br><br>但是我看到菜单里还有个菜：“这个大拌菜要12 啊，米饭2块啊，这怎么说？”<br><br>姑父：“像凉拌菜、米饭、饮料这种，只要点到，我就赚到，我白给他都行，明白吗？”<br><br>题主，你明白了么？<br><br></p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p>&gt;&gt; 转自：<a href="https://www.zhihu.com/question/422108658/answer/2366234987">我家里新开了个饭店，很多客人结账时要求抹零，该怎么解决这种问题？</a> - <a href="https://www.zhihu.com/people/xin-yi-82-25">心一</a>的回答 - 知乎</p>]]></content>
    
    
    <categories>
      
      <category>Career</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知乎</tag>
      
      <tag>定价</tag>
      
      <tag>抹零</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>做小生意真的比打工强吗？</title>
    <link href="/2024/02/13/%E5%81%9A%E5%B0%8F%E7%94%9F%E6%84%8F%E7%9C%9F%E7%9A%84%E6%AF%94%E6%89%93%E5%B7%A5%E5%BC%BA%E5%90%97%EF%BC%9F/"/>
    <url>/2024/02/13/%E5%81%9A%E5%B0%8F%E7%94%9F%E6%84%8F%E7%9C%9F%E7%9A%84%E6%AF%94%E6%89%93%E5%B7%A5%E5%BC%BA%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>本人在塞里斯十几年，虽然入职的是很高大上的单位，但我单位有大量的行业调研数据加上亲自ipc考察过许许多多小微生意，我觉得我很有发言权。<br><strong>我要来给你泼点凉水和熬点鸡汤。</strong><br><strong>既然是小生意，那我们首先排除什么大宗进出口，大型加工，大型工程 ，金融证券银行保险房地产等等这些技术密集，资本密集，最主要关系密集的玩意儿。</strong><br><strong>从你这个打工人实际能干的说起。</strong><br><strong>一</strong>，比如饭店和早餐摊位，我可以很明白告诉你，你没戏。<br>大饭店大酒店我们不谈，你肯定没戏，这既需要大量经验又需要资金支持还需要本地强力关系更要八面玲珑的会做人。<br>先谈有店面的小饭店，这里分三种，第一种，做家常炒菜，客人进来点几个菜的，这种店纯粹凭厨师个人技艺，你没戏，除非你有亲兄弟亲爹妈亲儿女当厨师那种，你想雇个厨师，这不可能，人性问题<br>第二种，特色单价菜品，比如地锅鸡，酸菜鱼，讲究一个锅子加点配菜能吃好久 ，厨房不用炒菜，能让上班族吹牛几小时，定价168以下，能做吗？做不了！ 首先你很难品控，其次就是地理位置，什么位置富集这种吹牛几小时下班来吃呢？这种位置的房东也早已心知肚明，基本沦落给房东打工<br>第三种，黄焖鸡米饭，沙县小吃，面馆等，同理，也是最后沦落到给房东打工<br>有店面的饭店，根本不用去算什么翻桌率，什么60毛利生死线，什么渠道进货，什么菜单，什么水电煤等等等 ，房东比你门清多了，除非你有个优秀厨师的亲人，就搞个小门头，不然活下来的都是给房东打工，活不下来的就是地理问题<br>那么不要店面的摆摊行不行？<br>更加不行，不在于吃苦吃累，而是黄金摊位你没资格摆，摆摊界也有江湖，你在写字楼门口摆个早饭摊是不现实的 ，不被掀掉是不可能的。<br><strong>二，奶茶店，咖啡店，小区咖啡店，民宿，小型电竞网吧</strong><br>必死无疑，绝对死翘翘，没有疑问的死翘翘，三大坑不是开玩笑的，不用好奇原理，保证死翘翘<br><strong>三，开小加工厂。</strong><br>必死无疑 ，毫无疑问，不用多想，开之前胸脯拍的通红的下游直接给你拉一年账期都有可能，称兄道弟的上游全是款到发货，工人，消防，厂房，物流发货，根本不是能随便应付的。而且这种厂会有很多错觉，订单一直有 ，好像垫垫资就能挺过去，银行也乐意放，最后借贷到倾家荡产，家破人亡。<br><strong>四，教培</strong><br><br>主课教培一来打击的严，二来纯靠口碑，纯口碑行业，很难搞。<br><br>美术，跳舞，画画，音乐等等也不是不行，主要也是房租问题，正规场地根本不可能，一堆未成年人挤一块的合法合规场地不是普通人能负担的<br>你得真有本事，并且是本地人，会聊会谈让家长信任，那么你搞个小场地也能赚，比打工会好一点吧，前提是你真有这方面的技能。你如果想着什么招老师，那我劝你省省。<br><strong>五，鲜花店，服装店，小卖部小超市水果店菜场</strong><br>前两个呢，二奶喜欢的，既然是二奶喜欢的你说那是来创业的嘛？那是来cos打发时间的一种情趣play。<br>当然也有能赚钱的鲜花店，那你得学会扫楼，学会不要脸的去搞渠道，要时间积累。赚钱的小服装店更是全靠老顾客，你这得相当会做人<br><br>至于小卖部小超市水果店菜场，跟饭店类似，不赚钱的有各种死法，赚钱的都是有里面的江湖，比如位置，比如优秀的进货渠道，而这又是要靠那么点关系，级别一点都不高的关系，可你不认识啊，关键是你不认识。<br><br><br><br>其余什么装修汽修开锁这种靠手艺吃饭的就不多说了，看你有没有这手艺吧。<br><br><br><br><strong>和大多数回答不一样的是，你自己对照一下上面，你有没有手艺？有没有关系？有没有渠道？没有的话老老实实呆着。</strong><br><br><br><br><br><br><br><br><strong>但我可以再给你来点鸡汤。</strong><br><br><strong>一，力推中医相关。</strong><br><strong>资格证去河南进修，那里突破口很大，你真想搞你自己去打听，河南那一定能搞定。</strong><br><strong>回来搞个中医馆，买本古汉语词典，读古文观止，词汇有点修养，搞吧，药丸里别搓现代药物进去就行，你就随便搞，别丧良心让人不打胰岛素不吃降压药就行，随便搞点什么，周边小区的退休资金能被你吸成漩涡。</strong><br>一年百万那是轻轻松松，而且完全合法。<br><strong>二 传媒相关。</strong><br>就拿二十万到五十万出来，租个十套公寓，精装的，偏远位置，两三万一个月差不多了，你就招广西云南那的小妹，大专的都不能要，中专初中肄业刚满十八那种，人要瘦，脸要小，腿要长，身上要有纹身。<br><br>你就画大饼，拼命画，丝袜吊带买足，你就搞直播，就搞，要会聊大哥，手机里十几个微信，你就聊，两三个月就能搞条稳定流水线出来，就真的赚，但我劝你洁身自好一点，也别拍那种纯涩视频发，就擦边就要礼物 ，红包都不收。<br><br><br><br>这两个都是很有前途的，有人看的话继续更，没人看算了。<br></p><p>转自<a href="https://www.zhihu.com/question/22394536/answer/3379509954">做小生意真的比打工强吗？ - 永远感恩的回答 - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>Career</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知乎</tag>
      
      <tag>打工</tag>
      
      <tag>小生意</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>民可使由之，不可使知之</title>
    <link href="/2024/02/12/%E6%B0%91%E5%8F%AF%E4%BD%BF%E7%94%B1%E4%B9%8B%EF%BC%8C%E4%B8%8D%E5%8F%AF%E4%BD%BF%E7%9F%A5%E4%B9%8B/"/>
    <url>/2024/02/12/%E6%B0%91%E5%8F%AF%E4%BD%BF%E7%94%B1%E4%B9%8B%EF%BC%8C%E4%B8%8D%E5%8F%AF%E4%BD%BF%E7%9F%A5%E4%B9%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>子曰：“兴于诗，立于礼，成于乐。”</p></blockquote><p>兴，兴起，起始。立，自立，立足于社会。成，完成。</p><p>诗，诗经，也可理解为基本的文学素养，包含识字、历史、音律、民俗等包罗万象的内容。礼，周礼，礼节，社会互动之基本规则。乐，音乐。</p><p>一个人，以学习文字的听说读写为起点；在成长过程中学习社会的经济制度、社会制度、文化制度，认识社会的运行、社交的礼仪，由此得以立足于社会；在此基础之上，遵循自身的兴趣和社会主流文化，选择并坚持自己的志趣，从而完成自我实现。<br><br></p><blockquote><p>子曰：“民可使由之，不可使知之。”</p></blockquote><p>这句话解读版本较多。</p><ul><li><p>愚民说（对君）：可以指导人（效法）做什么，但不可以让他知道为什么这么做。</p></li><li><p>君君说（对君）：对于民，让他效法君（的崇德做法）是可实现的（able），让他完全理解这些（但缺少君的以身作则）是困难的（unable）。（因此君应当以身作则。）</p></li></ul><p>还有联系上文一起理解：</p><ul><li>对于“兴于诗，立于礼，成于乐”这件事，如果民可以达到（accessible）就让（encourage to follow）他这么做（this way），如果不能达到就让他知道（子孙／其他人）应该这么做。这一说法的立足之处在于其符合克己复礼的主张。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过量补充维生素B的副作用</title>
    <link href="/2024/02/10/%E8%BF%87%E9%87%8F%E8%A1%A5%E5%85%85%E7%BB%B4%E7%94%9F%E7%B4%A0B%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/"/>
    <url>/2024/02/10/%E8%BF%87%E9%87%8F%E8%A1%A5%E5%85%85%E7%BB%B4%E7%94%9F%E7%B4%A0B%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="过量补充维生素B的副作用"><a href="#过量补充维生素B的副作用" class="headerlink" title="过量补充维生素B的副作用"></a>过量补充维生素B的副作用</h2><ul><li>过量补充维生素B1（每天服用剂量超过5g），可能会引起心跳加快，发抖，疱疹，浮肿，过敏等副作用。</li><li>过量补充维生素B2，可能会引起感觉异常，比如瘙痒，刺痛等症状。服用维生素B2后，可能会出现尿液呈亮黄色的现象，这种情况不必担心，是药物排泄的正常颜色，停药后即可恢复。</li><li>过量服用维生素B3（烟酸），会出现皮肤潮红、瘙痒，胃痛恶心等消化道症状，肝功能异常以及视物模糊等症状。另外，维生素B3还会影响尿酸的排泄，高尿酸患者应该慎用补充剂。</li><li>补充维生素B6（吡哆醇）过量，可以导致神经系统出现问题，甚至可能导致皮肤感觉丧失。</li><li>过量补充维生素B9（叶酸），会掩盖维生素B12缺乏的问题，导致神经或血液系统出现问题，同时过量补充叶酸，还有可能影响锌的吸收。</li><li>过量补充维生素B12，会导致心悸、心前区疼痛等心血管症状，同时还有可能出现皮疹、哮喘、寒颤等过敏症状，还可能导致叶酸的缺乏。</li></ul><h2 id="【补充知识】"><a href="#【补充知识】" class="headerlink" title="【补充知识】"></a>【补充知识】</h2><h3 id="一、维生素B介绍"><a href="#一、维生素B介绍" class="headerlink" title="一、维生素B介绍"></a>一、维生素B介绍</h3><p>维生素是人体所需的一大类营养素，而B族维生素就是其中的重要一类。之所以称之为“族”，是因为不同于维生素A、维生素C等具有固定结构的维生素，这类维生素是一大类水溶性维生素的总称。</p><p>在B族维生素中，我们常见的有维生素B1，维生素B2，维生素B3（烟酸），维生素B5（泛酸），维生素B6（吡哆醇），维生素B9（叶酸），维生素B12（钴胺素）等多种。</p><h3 id="二、B族维生素共同点"><a href="#二、B族维生素共同点" class="headerlink" title="二、B族维生素共同点"></a>二、B族维生素共同点</h3><ol><li>其理化特性上有一定的相似性。所有的B族维生素都是水溶性的维生素，因此难以在人体内大量贮存，通常可通过汗液、尿液等体液排出。</li><li>其生理功能有相互交叉。在营养身体的神经系统、维持造血功能，改善身体代谢能力，维护皮肤黏膜健康等方面，B族维生素都发挥着重要的作用。</li><li>相互之间有一定的协同作用。只有全面的保持各种营养的均衡充足，才能够更好的发挥其生理功能。比如维生素B2的缺乏，会影响维生素B6的吸收和利用。</li></ol><h3 id="三、补充维生素B的建议"><a href="#三、补充维生素B的建议" class="headerlink" title="三、补充维生素B的建议"></a>三、补充维生素B的建议</h3><ol><li>通常情况下，每日从饮食中摄入的B族维生素能够满足人体所需，没有必要服用额外的补充剂。在我们的日常膳食中，B族维生素可以说来源还是非常多的，不管是谷物、豆类，还是动物内脏，不管是蔬菜，还是各种水果，不管是蛋黄还是肉类，其中都含有各种各样的B族维生素，如果能够在日常生活中能够保持均衡营养的合理膳食，是不会缺乏维生素B的。</li><li>如果身体确实存在缺乏B族维生素的情况，也可以在日常膳食以外，通过服用补充剂来补充B族维生素。比如缺乏维生素B1导致的脚气病，缺乏维生素B2导致的口唇炎、阴部瘙痒等问题，叶酸摄入不足导致的血同型半胱氨酸偏高等问题，前提是要确定确实缺乏，必要时可咨询医生、采取血液检查。</li><li>建议选择价格便宜量又足的“药字号”产品。比如最常见的复合维生素B片，里面含有维生素B1，B2，B3，B5，B6，一瓶100片只要几元钱，是补充B族维生素的好选择。不建议选择价格高昂，质量还不一定有保证的保健品。包装上印着“国药准字H****”的，就是药字号产品。</li><li>对于B族维生素的补充，一是要强调针对性：缺什么？缺多少？缺哪种，就可以服用补充剂适量补充。虽然B族维生素长期服用通常安全性也较高，其水溶性的特性也会使过量补充的B族维生素通过尿液排出体外，但过量补充B族维生素同样可能产生不良反应风险。</li></ol><details><summary>文章来源</summary><li>原网页</li><a href="https://www.cn-healthcare.com/articlewm/20200427/content-1108223.html">维生素B适量补充很重要，医生提醒：过量补充，6种不良反应要注|导致|维生素|-健康界</a><li>网页快照（2023.03.09）</li><img src="https://pic2.zhimg.com/v2-44b385a444e188664414c42167a802f1_r.jpg" alt="网页快照"></details><p>本文转自 <a href="https://zhuanlan.zhihu.com/p/612640750">https://zhuanlan.zhihu.com/p/612640750</a>，如有侵权，请联系删除。</p>]]></content>
    
    
    <categories>
      
      <category>Health</category>
      
    </categories>
    
    
    <tags>
      
      <tag>维生素B</tag>
      
      <tag>维生素</tag>
      
      <tag>过量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity1 - Gamer羽飞</title>
    <link href="/2024/02/08/unity1/"/>
    <url>/2024/02/08/unity1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>一定要多练习</li><li>扩展发散</li><li>学完后尝试建立自己的游戏框架</li></ol><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="场景区"><a href="#场景区" class="headerlink" title="场景区"></a>场景区</h3><ul><li>中键: 同Q</li><li>右键+wasd: 作为player移动</li><li>Alt+左键: 转动视角</li><li>E: 旋转Rotate</li><li>R: 缩放Scale</li><li>T: 矩形缩放Rect，只管一个平面矩形的缩放，一般用于2D平面，如UI</li><li>Y: 全都有</li></ul><h2 id="Game-Object"><a href="#Game-Object" class="headerlink" title="Game Object"></a>Game Object</h2><ul><li>Sphere平面和Quad矩形的区别<ul><li>Sphere三角面更多, 可以支撑更精确复杂的计算; Quad三角面只有两个</li><li>Sphere一般没有y, Quad一般没有z</li></ul></li><li>不同GO的本质区别在于不同GO的Mesh Filter组件中Mesh属性的取值不同</li></ul><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><ul><li>在C#中通过Transform实例化的对象来访问对象本身的Position，Rotation变量是世界坐标系下的值。<br><code>transform.position; transform.rotation;</code></li><li>若想获取与组件上的本地坐标则应访问<code>transform.localPosition</code>和<code>transform.localRotation</code></li><li>从世界坐标转成相对父对象的局部坐标: <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">transform.TransformPoint(transform.localPosition);<br><span class="hljs-comment">//局部坐标转世界坐标</span><br>transform.parent.InverseTransformPoint(transform.position);<br><span class="hljs-comment">//世界坐标转局部坐标</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="游戏资源管理"><a href="#游戏资源管理" class="headerlink" title="游戏资源管理"></a>游戏资源管理</h2><ul><li>导入导出包UnityPackageFile: unity自身的一个压缩包</li><li>fbx: 3D模型文件</li><li>默认Material材质不可更改, 更改需要新建一个Material并应用到对应的GO上. 通过GO的MeshRenderer组件中Material组件可以添加各自的Material, 不同的Material通过选定的Shader着色器(默认Standard)渲染到GO上. </li><li>Window-&gt;Package Manager管理在Assets Store下载的资源包</li></ul><h2 id="Terrain地形"><a href="#Terrain地形" class="headerlink" title="Terrain地形"></a>Terrain地形</h2><ol><li>添加相邻地形</li></ol><ul><li>FillHeightmapUsing: 连接地形的方法<ul><li>clamp: 相邻瓦片交叉混合</li><li>mirror: 镜像</li></ul></li></ul><ol start="2"><li>绘制地形<blockquote><p>Opacity: 不透明度</p></blockquote></li></ol><ul><li>Paint Holes: 镂空画洞</li><li>Set Height: 设置高度<ul><li>Flatten Tile: 展平当前terrain</li><li>Flatten All: 展平所有terrain</li></ul></li><li>Smooth Height: 平滑高度<ul><li>Blur Direction: 仅向下舍去-1,双向0,仅向上进入1</li></ul></li><li>Stamp Terrain: 只能点一下, 不能滑动绘制</li><li>Paint Texture: 绘制纹理<ul><li>在Terrain Layer中选择Texture资源<blockquote><p>Tips: 一般不用绘制, 只需要了解</p></blockquote></li></ul></li></ul><ol start="3"><li>画树</li></ol><ul><li>Mass Place Tree: 大量放置树</li></ul><ol start="4"><li>绘制细节</li></ol><ul><li>Add Grass Texture: 给地面添加草<ul><li>最终强度: 草的密集程度</li></ul></li></ul><ol start="5"><li>地形设置</li></ol><h2 id="脚本的生命周期"><a href="#脚本的生命周期" class="headerlink" title="脚本的生命周期"></a>脚本的生命周期</h2><p>![Unity官方图解](D:\Program Files\Typora\assets\unity1\f366aa7d27e1514bb579b495f09942bf.png)</p><ol><li><p>Awake：初始化时调用，通常使用为需要提前初始化的逻辑。比如单例赋值<code>private void Awake()&#123;Instance = this;&#125;</code></p></li><li><p>OnEnable：在对象启用时调用，处理每次显示时都需要进行初始化的逻辑，通常和OnDisable配合使用。<br>比如: 游戏逻辑使用并修改了变量<code>Number</code>，而下次显示时使用是又需要<code>Number = 1</code>，此时就可以写<code>private void Awake()&#123;Number = 1;&#125;</code></p></li><li><p>Start：仅当启用脚本实例时，才会在第一帧调用。通常使用为一些变量初始化逻辑。比如：获取指定物体：<code>private void Start()&#123;child1 = transform.GetChild(0);&#125;</code></p></li><li><p>Fixed Update：固定时间调用，所有物理计算和更新都在Fixed Update中处理，不受帧率影响。比如：一些物理属性的更新操作Force，Collider，Rigidbody等。</p></li><li><p>Update：每帧调用一次，根据帧率的快慢影响执行速度。通常的游戏逻辑都写在这里，比如：和玩家交换，当用户按下空格时进行执行什么操作。</p></li><li><p>LateUpdate：在Update完成后，每帧调用一次。常见用处是相机跟随主角，比如：主角在Update中移动，则可以在LateUpdate执行相机的移动，这将可以保证摄像机跟着的时候之前的逻辑一起完全执行完成。</p></li><li><p>OnMouseXXX: 通过鼠标的射线检测来判断鼠标当前位置是否碰到了挂载脚本游戏对象的碰撞体。</p><ul><li><p>前提：</p><ul><li>只能检测当前脚本挂载的游戏对象。</li><li>当前游戏对象需要有碰撞体。</li><li>不能有其他物体(UI)遮挡到此游戏对象。</li></ul></li><li><p>函数：</p><ul><li>OnMouseEnter: 鼠标进入时调用一次</li><li>OnMouseOver: 鼠标停留(经过)时一直调用</li><li>OnMouseExit: 鼠标退出时调用一次</li><li>OnMouseDown: 鼠标按下时调用一次</li><li>OnMouseDrag: 鼠标拖拽(按住)时一直调用</li><li>OnMouseUp: 鼠标抬起时调用一次</li></ul></li><li><p>应用（一般成对使用）：</p><ul><li>OnMouseEnter，OnMouseOver，OnMouseExit 一组。比如模拟选中状态：鼠标进入时物体变色，鼠标退出时再变回来。</li><li>OnMouseDown，OnMouseDrag，OnMouseUp 一组。比如射击游戏：鼠标按下拖拽时调整方向，抬起时发射子弹。</li><li>当鼠标按下并停留在当前游戏对象上时，OnMouseOver，OnMouseDrag会同时触发。</li></ul></li></ul></li><li><p>OnTriggerXX:</p><ul><li><p>函数</p><ul><li>OnCollisionEnter: 进入碰撞时触发一次。</li><li>OnCollisionStay: 在碰撞体中停留时每帧触发一次。</li><li>OnCollisionExit: 离开碰撞体时触发一次。</li><li>OnTriggerEnter: 进入碰撞体时触发一次。</li><li>OnTriggerStay: 在碰撞体中停留时每帧触发一次。</li><li>OnTriggerExit: 离开碰撞体是触发一次。</li></ul><blockquote><p>还有对应2D碰撞体的六个方法（如：<code>OnCollisionEnter2D</code>） 函数后面添加2D接口，触发条件和使用方式和3D一致。 使用时注意碰撞体和检测函数同步接口，即用2D碰撞体必须用2D函数。</p></blockquote></li><li><p>前提同上</p></li></ul></li><li><p>OnApplicationXX:</p><ul><li>函数:<ul><li>OnApplicationPause: 检测到暂停的帧结束 –&gt; 切换到后台和回来时调用。游戏停止保存数据&#x2F;游戏继续数据初始化。</li><li>OnApplicationFocus: 当屏幕 获得&#x2F;失去 焦点时调用。失去焦点关闭背景音乐&#x2F;获得焦点继续播放音乐。</li><li>OnApplicationQuit: 当程序退出时调用。在移动端大退时也会对调用，但不会触发上面两个方法。</li></ul></li></ul></li><li><p>禁用与销毁</p><ul><li><code>OnDisable</code>: 当对象被禁用时调用此函数（其父物体被禁用也会触发）。通常和OnEnable配合使用。比如：在OnEnable添加监听，在OnDisable移除监听</li><li><code>OnDestroy</code>: 在对象存在的最后一帧的所有帧更新之后调用此函数。当物体销毁或者场景关闭时触发。比如：子弹打到墙壁时，需要销毁子弹并触发一个打击音效。</li></ul></li></ol><h2 id="脚本执行顺序"><a href="#脚本执行顺序" class="headerlink" title="脚本执行顺序"></a>脚本执行顺序</h2><ul><li><p>先执行所有的<code>Awake()</code>, 再执行所有的<code>Start()</code></p></li><li><p>Execution Order中设置cs脚本执行顺序, 数值越小越先执行</p></li></ul><h2 id="标签和图层"><a href="#标签和图层" class="headerlink" title="标签和图层"></a>标签和图层</h2><ul><li>给GO分组的工具</li><li>图层可以在Camera组件Culling Mask属性中选择遮罩图层, 实现显隐不同图层的功能</li></ul><h2 id="Prefab预制体与变体"><a href="#Prefab预制体与变体" class="headerlink" title="Prefab预制体与变体"></a>Prefab预制体与变体</h2><ul><li><p>以.prefab文件存储的GO, 可以通过GO快速创建别人打包好的GO</p></li><li><p>在Scene中的GO组件发生改变, 可以通过右键组件应用到Prefab文件的修改</p></li><li><p>通过预制体创建的GO发生大改变, 将GO独立为新的prefab时, 选择<code>原始预制体</code>将保留对原始预制体的引用, 选择<code>预制体变体</code>将不再保留对原始预制体的引用</p></li><li><p>通过代码来创建GO就可以考虑使用预制体</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> GameObject sphere; <span class="hljs-comment">//首先public一个GO变量, 然后在unity面板中拖入特定的预制体</span><br>Instantiate(sphere,transform); <span class="hljs-comment">//使用Instantiate初始化这个变量, 并将其设置为当前GO的子GO.该函数返回值为go对象</span><br>Destroy(Instantiate(sphere,transform)); <span class="hljs-comment">//创建并销毁go</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="Vector3"><a href="#Vector3" class="headerlink" title="Vector3"></a>Vector3</h2><ul><li><p>常用常量</p><ul><li><p><code>Vector3.zero</code>: (0,0,0)</p></li><li><p><code>Vector3.one</code>: (1,1,1)</p></li></ul></li><li><p>函数</p><ul><li><p><code>Vector3.Angle(new Vector3(0,0,0),new Vector3(1,1,1))</code>: 两个向量之间的夹角</p></li><li><p><code>Vector3.Distance(new Vector3(0,0,0),new Vector3(1,1,1))</code>: 两个坐标之间的距离</p></li><li><p><code>Vector3.Dot(new Vector3(0,0,0),new Vector3(1,1,1))</code>: 两个向量的乘积(返回&#x3D;&#x3D;标量&#x3D;&#x3D;)</p><blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//Dot源码</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">float</span> <span class="hljs-title">Dot</span>(<span class="hljs-params">Vector3 lhs, Vector3 rhs</span>)</span><br>&#123;<br> <span class="hljs-keyword">return</span> lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>a</strong>⋅<strong>b</strong>&#x3D;(x<del>1</del>,y<del>1</del>,z<del>1</del>)⋅(x2,y2,z2)&#x3D;x1×x2+y1×y2+z1×z2&#x3D;|<strong>a</strong>|×|<strong>b</strong>|×<em>cos</em>θ</p><p>通过<strong>取值正负</strong>可以判断两向量<strong>方向是否相同</strong>; 通过<strong>取值是否为0</strong>可以判断<strong>是否垂直</strong></p></blockquote></li><li><p><code>Vector3.Cross(new Vector3(0,0,0),new Vector3(1,1,1))</code>: 两个向量的叉乘(返回&#x3D;&#x3D;Vector3对象&#x3D;&#x3D;)</p><blockquote><p>&#x2F;&#x2F;Cross源码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector3 <span class="hljs-title">Cross</span>(<span class="hljs-params">Vector3 lhs, Vector3 rhs</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>a</strong>×<strong>b</strong>&#x3D;(a1,a2,a3)×(b1,b2,b3)&#x3D;(a2×b3−a3×b3,a3×b1−a1×b3,a1×b2−a2×b1))</p><p>|<strong>a</strong>×<strong>b</strong>|&#x3D;|<strong>a</strong>|×|<strong>b</strong>|×sinβ</p><p>叉乘的几何意义表示为求得以<strong>a</strong>和<strong>b</strong>为平面的法线向量<strong>c</strong>, <strong>c</strong>⊥<strong>a</strong>与<strong>b</strong>组成的平面, <strong>c</strong>的模|<strong>c</strong>|&#x3D;|<strong>a</strong>|×|<strong>b</strong>|×sinβ, 或以<strong>a</strong>和<strong>b</strong>组成的平行四边形的面积</p><p>若两者叉乘之模为0, 则<strong>a</strong>与<strong>b</strong>相互平行; 若两者叉乘之模等于两者各自的模的乘积, 则<strong>a</strong>与<strong>b</strong>相互垂直</p></blockquote></li><li><p><code>Vector3.Lerp(new Vector3(0,0,0),new Vector3(1,1,1),0.5f)</code>: 两个Vector3之间插值</p></li></ul></li><li><p>对象常量(<code>Vector3 v = new Vector3(1,1,1);</code>)</p><ul><li><code>v.magnitude</code>: Vector3的模</li></ul></li></ul><h2 id="Euler欧拉角与Quaternion四元数"><a href="#Euler欧拉角与Quaternion四元数" class="headerlink" title="Euler欧拉角与Quaternion四元数"></a>Euler欧拉角与Quaternion四元数</h2><ul><li><p>Euler的实例化: 同Vector3</p><p><code>Vector3 rotate = new Vector3(0,30,0);</code></p></li><li><p>Quaternion的实例化: </p><ul><li>常量(0,0,0,0): <code>Quaternion.identity</code></li><li>欧拉角to四元数: <code>Quaternion quaternion = Quaternion.Euler(new Vector3(0,30,0));</code></li><li>四元数to欧拉角: <code>Vector3 vector3 = quaternion.eulerAngles;</code></li></ul></li></ul><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><ul><li>输出文本Text: <ul><li>调试输出: <code>Debug.log(&quot;Text&quot;);</code></li><li>调试输出警告: <code>Debug.logWarning(&quot;Text&quot;);</code></li><li>调试输出错误: <code>Debug.logError(&quot;Text&quot;);</code></li></ul></li><li>画线<ul><li>画直线: <code>Debug.DrawLine(Vector3.zero,Vector3.one,[Color.Green]); //两个必需参数为两个点坐标</code></li><li>画射线: <code>Debug.DrawRay(Vector3.zero,Vector3.one,[Color.Green]); //第一个参数是起始点坐标, 第二个参数为射线向量</code></li></ul></li></ul><h2 id="组件属性的修改"><a href="#组件属性的修改" class="headerlink" title="组件属性的修改"></a>组件属性的修改</h2><ul><li><p>获取GO和transform: </p><ul><li><p>获取本GO: <code>GameObject go = this.gameObject;</code> 也可直接使用<code>gameObject</code>代替<code>this.gameObject</code> </p><blockquote><p>GO的父子关系控制在<code>transform</code>组件中, 上面的<code>this</code>表示的是本<code>GO</code>的<code>transform</code>, 所以上面的<code>this.gameObject</code>也可以写为<code>transform.gameObject</code></p></blockquote></li><li><p>获取其他无关GO: </p><ul><li><p><code>public GameObject go;</code> 然后通过unity面板选择</p></li><li><p><code>GameObject.Find(&quot;name&quot;)</code>; 使用<code>GameObject</code>类方法根据name寻找</p></li><li><p><code>GameObject.FindWithTag(&quot;tag&quot;)</code>; 使用<code>GameObject</code>类方法根据tag寻找</p></li></ul></li><li><p>获取父物体GO:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">Transform parent = transform.parent; <span class="hljs-comment">// 获取物体的直接父物体</span><br>Transform root = transform.root; <span class="hljs-comment">// 获取物体的根物体</span><br><span class="hljs-built_in">int</span> hierarchy = transform.GetSiblingIndex(); <span class="hljs-comment">// 获取物体在父物体中的层级索引.根物体的层级索引为0，其直接子物体的层级索引依次递增</span><br></code></pre></td></tr></table></figure></li><li><p>获取子物体GO: </p><ul><li>获取所有层级所有子物体, 包括本物体: <code>GetComponentsInChildren()</code></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">Transform[] myTransforms = GetComponentsInChildren&lt;Transform&gt;();<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> child <span class="hljs-keyword">in</span> myTransforms)&#123;Debug.Log(child.name);&#125;<br></code></pre></td></tr></table></figure><ul><li><p>通过name获取<strong>一级</strong>子物体: <code>transform.Find(&quot;Child0&quot;)</code></p><blockquote><p>获取<strong>二级</strong>子物体需要<strong>全路径</strong>: <code>transform.Find(&quot;Child0/Child00&quot;)</code></p><p>&#x3D;&#x3D;注意: 对象<code>gameObject</code>没有此方法, <code>transform</code>有此方法, <code>transform</code>对象的方法只能寻找本身及子物体, <code>GameObject</code>类方法是从所有层级所有物体中寻找&#x3D;&#x3D;</p></blockquote></li><li><p>通过index获取一级子物体: <code>transform.GetChild(1)</code></p><blockquote><p>获取<strong>二级</strong>子物体需要<strong>连续两次调用</strong>: <code>transform.GetChild(1).GetChild(0)</code></p></blockquote></li></ul></li><li><p><code>GameObject</code>类的实例化需要到unity面板中选择, 在代码中的<code>gameObject</code>是<code>transform</code>对象的一个属性, 获得的所有父子GO物体均为相应的<code>transform</code>对象</p></li></ul></li><li><p>GO&#x2F;transform的属性和函数: </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#">go.name<br>go.tag<br>go.layer<br>go.activeInHierarchy <span class="hljs-comment">//是否激活状态在层级中</span><br>go.activeSelf <span class="hljs-comment">//本身是否激活状态</span><br><span class="hljs-comment">//两个同时为真才是激活状态, 只要有一个为假就不是激活状态</span><br>go.AddComponent&lt;BoxCollider&gt;(); <span class="hljs-comment">//添加组件</span><br>go.SetActive(<span class="hljs-literal">true</span>); <span class="hljs-comment">//设置是否激活, 这是go的函数, transform无法管控GO是否激活</span><br></code></pre></td></tr></table></figure></li><li><p>获取其他组件: <code>BoxCollider bc = GetComponent&lt;BoxCollider&gt;();</code>或直接使用匿名函数接想用的属性<code>GetComponent&lt;BoxCollider&gt;().xxx</code></p></li><li><p>获取父物体的特定组件: <code>GetComponentInParent&lt;BoxCollider&gt;()</code></p></li><li><p>获取子物体的特定组件: <code>BoxCollider[] bc = GetComponentInChidren&lt;BoxCollider&gt;()</code>, 会遍历包含本身在内的所有层级所有子物体</p></li></ul><h2 id="Time类"><a href="#Time类" class="headerlink" title="Time类"></a>Time类</h2><ol><li><p>Time类属性</p><table><thead><tr><th>总时间</th><th></th></tr></thead><tbody><tr><td><code>Time.time</code></td><td>帧时间</td></tr><tr><td><code>Time.unscaledTime</code></td><td>不受Scale约束的帧时间</td></tr><tr><td><code>Time.fixedTime</code></td><td>频率时间&#x2F;不受帧约束的时间</td></tr><tr><td><code>Time.unscaledFixedTime</code></td><td>不受Scale约束的频率时间</td></tr><tr><td><code>Time.realtimeSinceStartup</code></td><td>不受Scale影响的实际时间</td></tr><tr><td><code>Time.timeSinceLevelLoad</code></td><td>自最后一个非添加场景（non-additive scene）完成加载以来的Scaled时间</td></tr><tr><td><strong>增量时间</strong></td><td></td></tr><tr><td><code>Time.deltaTime</code></td><td>帧间隔时间&#x2F;Δ帧时间</td></tr><tr><td><code>Time.unscaledDeltaTime</code></td><td>不受Scale约束的帧间隔时间</td></tr><tr><td><code>Time.fixedDeltaTime</code></td><td>频率间隔时间&#x2F;不受帧约束的时间间隔</td></tr><tr><td><code>Time.fixedUnscaledDeltaTime</code></td><td>不受Scale约束的频率间隔时间</td></tr><tr><td><strong>其他</strong></td><td></td></tr><tr><td><code>Time.frameCount</code></td><td>总帧数</td></tr><tr><td><code>Time.timeScale</code></td><td>时间缩放尺度, 默认为1, 为0停止, 为2二倍速</td></tr><tr><td><code>Time.maximumDeltaTime</code></td><td>最大帧增量时间</td></tr><tr><td><code>Time.maximumParticleDeltaTime</code></td><td>粒子更新的最大帧增量时间</td></tr></tbody></table><ul><li>过于卡顿时, <code>Time.deltaTime</code>会增大, 但不会无限增大, 受<code>Time.maximumDeltaTime</code>限制, 而<code>Time.unscaledDeltaTime</code>不受此限制, 因此<code>Time.time</code>会比<code>Time.unscaledTime</code>慢一些.</li></ul></li></ol><h2 id="Application类"><a href="#Application类" class="headerlink" title="Application类"></a>Application类</h2><table><thead><tr><th>静态变量</th><th></th></tr></thead><tbody><tr><td><code>Application.persistentDataPath</code></td><td>不同平台持久化的Assets文件夹(读写)</td></tr><tr><td><code>Application.streamingAssetsPath</code></td><td>游戏安装目录Assets目录中<code>streamingAssets</code>文件夹, 无加密(只读)</td></tr><tr><td><code>Application.temporaryCachePath</code></td><td>临时文件夹</td></tr><tr><td><code>Application.runInBackground</code></td><td>是否在后台运行</td></tr><tr><td><code>Application.platform</code></td><td>返回游戏运行平台(只读)</td></tr><tr><td><code>Application.systemLanguage</code></td><td>返回系统语言(只读)</td></tr><tr><td><code>Application.unityVersion</code></td><td>返回unity版本</td></tr><tr><td><strong>静态函数</strong></td><td></td></tr><tr><td><code>Application.OpenURL(&quot;http&quot;)</code></td><td>打开URL</td></tr><tr><td><code>Application.Quit</code></td><td>退出游戏</td></tr></tbody></table><h2 id="Scene类与SceneManagement类"><a href="#Scene类与SceneManagement类" class="headerlink" title="Scene类与SceneManagement类"></a><code>Scene</code>类与<code>SceneManagement</code>类</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> UnityEngine.SceneManagement <span class="hljs-comment">//引入namespace使用SceneManager类</span><br>SceneManager.LoadScene(<span class="hljs-number">1</span>); <span class="hljs-comment">//在File-BildSettings中引入不同scene获得index, 通过index加载scene</span><br>SceneManager.LoadScene(<span class="hljs-string">&quot;MyScene&quot;</span>,[defalt:LoadSceneMode.Single]LoadSceneMode.Addictive); <span class="hljs-comment">//通过name加载scene</span><br>SceneManager.UnloadSceneAsync(s); <span class="hljs-comment">//卸载scene</span><br><br>Debug.log(SceneManager.sceneCount); <span class="hljs-comment">//数量</span><br><br>Scene s = SceneManager.GetActiveScene(); <span class="hljs-comment">//当前活动scene</span><br>Scene s = SceneManager.CreateScene(<span class="hljs-string">&quot;MyScene&quot;</span>); <span class="hljs-comment">//创建scene</span><br><br>Debug.log(s.name); <span class="hljs-comment">//名字</span><br>Debug.log(s.isLoaded); <span class="hljs-comment">//是否已加载</span><br>Debug.log(s.path); <span class="hljs-comment">//文件路径</span><br>Debug.log(s.buildIndex); <span class="hljs-comment">//获取index</span><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//异步加载场景需要用IEnumerator协程:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTest</span>:<span class="hljs-title">Monobehavior</span><br>&#123;<br>    AsyncOperation o; <span class="hljs-comment">//实例化一个AsyncOperation对象用以记录加载过程信息</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        StartCoroutine(loading()); <span class="hljs-comment">//使用StartCoroutin()启动协程, 参数为协程函数名</span><br>    &#125;<br>    <br>    <span class="hljs-function">IEnumerator <span class="hljs-title">loading</span>() <span class="hljs-comment">//定义协程事件</span></span><br>    &#123;<br>        o = SceneManager.LoadSceneAsync(<span class="hljs-string">&quot;MyScene&quot;</span>/<span class="hljs-number">1</span>); <span class="hljs-comment">//在协程中使用异步加载场景函数, 函数返回值为AsyncOperation类对象</span><br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> o; <span class="hljs-comment">//将加载过程的信息写入o中</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        Debug.log(o.progress); <span class="hljs-comment">//0-0.9</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Transform类"><a href="#Transform类" class="headerlink" title="Transform类"></a>Transform类</h2><table><thead><tr><th>实例变量</th><th></th></tr></thead><tbody><tr><td><code>transform.position</code></td><td>世界位置</td></tr><tr><td><code>transform.localPosition</code></td><td>相对位置</td></tr><tr><td><code>transform.rotation</code></td><td>世界旋转四元数</td></tr><tr><td><code>transform.localRotation</code></td><td>相对旋转四元数</td></tr><tr><td><code>transform.eulerAngles</code></td><td>世界旋转欧拉角</td></tr><tr><td><code>transform.localEulerAngles</code></td><td>相对旋转欧拉角</td></tr><tr><td><code>transform.localScale</code></td><td>缩放</td></tr><tr><td><code>transform.forward</code></td><td>GO的前后左右上下</td></tr><tr><td><strong>实例函数</strong></td><td></td></tr><tr><td><code>transform.LookAt(Vector3.zero)</code></td><td>一直看向某一个点(点坐标)</td></tr><tr><td><code>transform.Rotate(Vector3.up)</code></td><td>旋转(方向向量)</td></tr><tr><td><code>transform.Translate(Vector3.forward * 50 * Time.deltaTime)</code></td><td>向(0,0,1)移动(方向向量)</td></tr></tbody></table><h2 id="Input类"><a href="#Input类" class="headerlink" title="Input类"></a>Input类</h2><ol><li><p>按键Key</p><table><thead><tr><th>静态属性</th><th></th></tr></thead><tbody><tr><td><code>Input.anyKey</code></td><td>如果用户按下任何键(包含任意设备任意输入)，在按住不放的过程中一直返回true（只读）</td></tr><tr><td><code>Input.anyKeyDown</code></td><td>按下任何键(包含任意设备任意输入),按下的那一帧返回true(只读),之后的帧即使仍然被按住也返回false</td></tr><tr><td><code>Input.inputString</code></td><td>按下的键的值(配合<code>anyKey</code>实现自定义按键)</td></tr><tr><td><strong>静态方法</strong></td><td></td></tr><tr><td><code>Input.GetKey(KeyCode)</code></td><td>检测是否按下了任何指定键,一直按住则一直返回 true</td></tr><tr><td><code>Input.GetKeyDown(KeyCode)</code></td><td>检测是否按下了任何指定键,只有那一帧时true</td></tr><tr><td><code>Input.GetKeyUp(KeyCode)</code></td><td>释放的那一帧返回true</td></tr></tbody></table></li><li><p>按钮Button</p><table><thead><tr><th><strong>静态方法</strong></th><th></th></tr></thead><tbody><tr><td><code>Input.GetButton(string buttonName)</code></td><td>检测是否按下了任何按钮,一直按住则一直返回 true</td></tr><tr><td><code>Input.GetButtonDown()</code></td><td>检测是否按下了任何button,只有那一帧时true</td></tr><tr><td><code>Input.GetButtonUp()</code></td><td>释放的那一帧返回true</td></tr></tbody></table></li><li><p>鼠标</p><table><thead><tr><th>静态属性</th><th></th></tr></thead><tbody><tr><td><code>Input.mousePresent</code></td><td>是否有mouse设备连接（只读）</td></tr><tr><td><code>Input.mousePosition</code></td><td>当前鼠标位置(只读), z&#x3D;0, 左下角是(0,0,0), 右上角是分辨率</td></tr><tr><td><code>Input.mouseScrollDelta</code></td><td>鼠标滚轮滚动量(只读), 返回<code>Vector2</code>, y逆时针(0,1), 顺时针(0,-1)</td></tr><tr><td><strong>静态方法</strong></td><td></td></tr><tr><td><code>Input.GetMouseButton(int button)</code></td><td>检测是否按下了按钮,一直按住则一直返回 true, 0左键 1右键 2中键</td></tr><tr><td><code>Input.GetMouseButtonDown()</code></td><td>检测是否按下,只有那一帧时true</td></tr><tr><td><code>Input.GetMouseButtonUp()</code></td><td>释放的那一帧返回true</td></tr></tbody></table></li><li><p>虚拟轴</p><ul><li>设置内容在<code>编辑-ProjectSettings</code>中</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">float</span> h = Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>); <span class="hljs-comment">//获取水平轴(-1,1)</span><br><span class="hljs-built_in">float</span> v = Input.GetAxis(<span class="hljs-string">&quot;Vertical&quot;</span>);<br><span class="hljs-built_in">float</span> x = Input.GetAxis(<span class="hljs-string">&quot;Mouse X&quot;</span>); <span class="hljs-comment">//获取鼠标横向从移动, 左-1</span><br></code></pre></td></tr></table></figure><p><code>Input.GetAxisRaw</code>只返回-1,0,1三个值,没有过渡态, 一般用于2D游戏中</p></li><li><p>触摸</p><table><thead><tr><th>静态属性</th><th></th></tr></thead><tbody><tr><td><code>Input.touchCount</code></td><td>返回整数，代表在当前帧所有触摸点数量（只读）</td></tr><tr><td><code>Input.touches</code></td><td>返回一个 Touch[] 数组(只读)，包含了当前帧所有触摸点</td></tr><tr><td><strong>静态方法</strong></td><td></td></tr><tr><td><code>Input.GetTouch(int index)</code></td><td>返回特定Touch</td></tr><tr><td><strong>对象属性</strong></td><td></td></tr><tr><td><code>touch.position</code></td><td></td></tr><tr><td><code>touch.phase</code></td><td>包含Began, Moved, Stationary, Ended, Canceled五个阶段的属性, 用switch判断</td></tr></tbody></table></li><li><p>陀螺仪&#x2F;重力感应</p><ul><li>前提: <code>Input.gyro.enabled = true;</code></li></ul><table><thead><tr><th>默认成员属性</th><th></th></tr></thead><tbody><tr><td><code>Input.gyro.gravity</code></td><td>重力加速度向量</td></tr><tr><td><code>Input.gyro.rotateRate</code></td><td>旋转速度</td></tr><tr><td><code>Input.gyro.attitude</code></td><td>当前的旋转方向的四元数</td></tr></tbody></table></li><li><p>设备按钮</p><p><code>Input.backButtonLeavesApp</code>: 这个值为<code>true</code>时，按下返回按钮会导致应用程序退出，否则，操作系统将处理返回按钮(Android、Windows Phone或Windows平板电脑)</p></li></ol><h2 id="Light组件-光照"><a href="#Light组件-光照" class="headerlink" title="Light组件: 光照"></a>Light组件: 光照</h2><ol><li>Directional定向光: 图穷远光源, 平行光线<ul><li>Intensity强度: 光照亮度</li><li>Shadow Type: 无阴影, 有锯齿阴影, 模糊边缘阴影</li><li>Realtime Shadows: 实时阴影<ul><li>Strength: 阴影强度</li><li>Resolution: 阴影质量</li></ul></li><li>Draw Halo: 在GO处显示光晕</li><li>Flare: 炫光</li><li>Culling Mask: 光照遮罩, 剔除不需要灯光的GO(如UI)</li></ul></li><li>Spot聚光: 手电筒</li><li>Point点光源: 灯泡球体光</li><li>Area面光源(性能消耗过高, 仅支持烘焙模式)</li></ol><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><ul><li><p>Projection投影: </p><ul><li>Perspective透视: 近大远小</li><li>Orthographic正交: 完全平面, 一般用于2D</li></ul></li><li><p>Depth: 相机显示顺序, 数值大的优先显示</p></li><li><p>Clear Flags清除标志: </p><ul><li><p>SkyBox天空盒: 可以添加SkyBox组件更改天空</p></li><li><p>Solid Color</p></li><li><p>Don’t Clear</p></li><li><p>Depth Only: 仅显示有深度GO, 拍不到的空间不显示</p><blockquote><p>如果有多个相机, 将深度高的相机设置为DepthOnly, 可以显示高深相机的内容和低深相机的内容&amp;背景</p></blockquote></li></ul></li><li><p>FOV Axis: 用于设置Field of View视野的大小</p></li><li><p>Clipping Planes剪裁平面: 只有在近面和远面之间的空间才能被捕捉到</p></li><li><p>Viewpoint Rect显示矩形: 拍摄到的内容在屏幕中的位置(x,y)和宽高(w,h), 位置默认左下角(0,0), 宽高是百分比小数</p></li></ul><h2 id="音频-AudioSource组件"><a href="#音频-AudioSource组件" class="headerlink" title="音频: AudioSource组件"></a>音频: AudioSource组件</h2><ul><li>前提: 有且只有一个GO添加了AudioListener组件用以监听</li><li>需要播放声音的GO中添加AudioSource组件</li><li>音频文件一般分为两类: 音乐和音效</li><li>AudioSource组件:<ul><li>AudioClip: 引入音频资源文件</li><li>Mute: 静音</li><li>Pitch: 音调</li><li>3D Sound Settings - Volume Rolloff: 音量衰减</li></ul></li><li>对象属性和函数:<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#">AudioSource a = GetComponent&lt;AudioSource&gt;();<br><br><span class="hljs-comment">//属性:</span><br>Debug.log(a.isPlaying);<br>a.loop = <span class="hljs-literal">true</span>;<br>a.volume = <span class="hljs-number">0.5f</span>;<br><br><span class="hljs-comment">//音乐函数:</span><br>a.Play();<br>a.Pause();<br>a.UnPause();<br>a.stop();<br><br><span class="hljs-comment">//音效函数:</span><br>a.PlayOneShot(AudioClip audioclip); <span class="hljs-comment">//一个AudioSource只能播放一个音乐,但可以播放多个音效</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="视频-VideoPlayer组件"><a href="#视频-VideoPlayer组件" class="headerlink" title="视频: VideoPlayer组件"></a>视频: VideoPlayer组件</h2><ul><li>使用VideoClip作为资源文件变量</li><li>VideoPlayer组件:<ul><li>Renderer Mode渲染模式: 选择挂载体</li><li>属性和函数参考<code>AudioSource</code></li></ul></li></ul><h2 id="角色控制-CharacterController组件"><a href="#角色控制-CharacterController组件" class="headerlink" title="角色控制: CharacterController组件"></a>角色控制: <code>CharacterController</code>组件</h2><ul><li><code>SimpleMove</code>: 自带重力效果, y轴速度为0, 角色接触地面返回true</li><li><code>Move</code>: 绝对控制, 没有重力效果, 影响位移的只有<strong>xyz的速度</strong>和**<code>Rigidbody</code>的碰撞**, 返回<code>CollisionFlags</code>对象</li></ul><h2 id="重力-Rigidbody组件"><a href="#重力-Rigidbody组件" class="headerlink" title="重力: Rigidbody组件"></a>重力: <code>Rigidbody</code>组件</h2><ul><li><code>automatic tensor</code>: 自动张量, 计算张量旋转行为</li><li><code>automatic center of mass</code>: 自动重心计算</li><li><code>interpolate</code>: 物体运动插帧, 一般在物理帧率低于app帧率时使用, 默认关闭<blockquote><p>Interpolate：使用前两次物理更新计算当前帧, 会稍滞后于它应该在的位置, 适用于刚体速度变化较大的情况或有其他影响刚体运动的物理元素<br><br>Extrapolate：使用上一次物理更新并预测下一次物理更新以计算当前帧, 会稍超前于它应该在的位置。外推通常不太准确，并且可能在可见的范围内超出碰撞边界（然后在下一帧中进行修正）。外推通常只适用于精度不重要的情况，例如刚体以恒定速度移动，并且没有其他影响刚体运动的物理元素</p></blockquote><blockquote><p>启用时Unity会忽略任何不是来自物理系统的变换更改, 对<code>transform</code>进行任何直接（非物理）更改后使用Physics.SyncTransforms调用</p></blockquote></li><li><code>Collision Detection</code>: 碰撞检测频率<ul><li><code>Discrete</code>: 离散检测(默认,多数情况够用)</li><li><code>Continues</code>: 连续</li><li><code>Continues Dynamic</code>: 连续动态检测, 性能消耗最高</li><li><code>Continues Speculative</code>: 处于Continues和Discrete之间</li></ul></li><li><code>Constraints</code>: 冻结某一方面的transform</li></ul><h2 id="碰撞-Collider组件"><a href="#碰撞-Collider组件" class="headerlink" title="碰撞: Collider组件"></a>碰撞: <code>Collider</code>组件</h2><ul><li>碰撞的条件: 两者都有<code>Collider</code>组件 &amp; 至少一个GO有<code>Rigidbody</code>组件</li><li>碰撞方法:<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collision</span>)</span>&#123;<br>  <span class="hljs-comment">//collision.colider: 与之碰撞的物体的collider</span><br>  <span class="hljs-comment">//collision.gameObject: 与之碰撞的GO对象</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionStay</span>(<span class="hljs-params">Collision collision</span>)</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionExit</span>(<span class="hljs-params">Collision collision</span>)</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter</span>(<span class="hljs-params">Collider other</span>)</span>&#123;<br>  <span class="hljs-comment">//other就是触发的collider</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerStay</span>(<span class="hljs-params">Collider other</span>)</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerExit</span>(<span class="hljs-params">Collider other</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><code>Material</code>: 使用<code>Physical Material</code>文件, 创建<code>Friction</code>摩擦力<ul><li><code>Bounciness</code>: 弹力, 1没有能量损失</li><li><code>Xx Combine</code>: 两个摩擦GO时如何计算</li></ul></li></ul><h2 id="铰链关节-弹簧关节和固定关节-Hinge-Joint-Spring-Jonit和Fixed-Joint组件"><a href="#铰链关节-弹簧关节和固定关节-Hinge-Joint-Spring-Jonit和Fixed-Joint组件" class="headerlink" title="铰链关节,弹簧关节和固定关节: Hinge Joint,Spring Jonit和Fixed Joint组件"></a>铰链关节,弹簧关节和固定关节: <code>Hinge Joint</code>,<code>Spring Jonit</code>和<code>Fixed Joint</code>组件</h2><ul><li><code>Anchor</code>: 轴原点</li><li><code>Axis</code>: 轴向量</li></ul><h2 id="射线检测"><a href="#射线检测" class="headerlink" title="射线检测"></a>射线检测</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>&#123;<br>  <span class="hljs-keyword">if</span>(Input.GetMouseButtonDown(<span class="hljs-number">0</span>))&#123;<br>    <span class="hljs-comment">//从Camera发射一个射线</span><br>    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);<br>    <span class="hljs-comment">// 声明一个RaycastHit对象接受hit结果</span><br>    RaycastHit hit;<br>    <span class="hljs-comment">//使用Physics.Raycast函数发射ray, 并将发射结果保存到引用参数hit中</span><br>    <span class="hljs-keyword">if</span>(Physics.Raycast(ray,<span class="hljs-keyword">out</span> hit))&#123;<br>      <span class="hljs-comment">//打印在3Dunity中与射线相撞的第一个rigidbody的撞击坐标</span><br>      Debug.log(hit.point);<br>    &#125;<br><br>    <span class="hljs-comment">//如果检测多个rigidbody相撞目标,需要实例化RaycastHit[]数组接收, 使用Physics.RaycastAll(Ray ray)多次检测</span><br>    RaycastHit[] hit = Physics.RaycastAll(ray,[<span class="hljs-built_in">int</span> 检测距离],[<span class="hljs-built_in">int</span> 检测图层],[...]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="粒子系统-Partical-System组件"><a href="#粒子系统-Partical-System组件" class="headerlink" title="粒子系统: Partical System组件"></a>粒子系统: <code>Partical System</code>组件</h2><ul><li><code>Prewarm</code>: 从stop开始时, 是否从0逐渐展开</li><li><code>Start Lifetime</code>: 粒子在空中的存在时间</li><li><code>3D Start Size/Rotation</code>: 开启后转换为3D粒子;默认为面向Camera的平面粒子</li><li><code>Flip Rotation</code>: 水平翻转旋转</li><li><code>Gravity Modifier</code>: 粒子重力效果<ul><li><code>Constant</code>: 固定值,[-1上重力,1下重力]</li><li><code>Curve</code>: 受力曲线</li></ul></li><li><code>Simulation Space</code>: 生成的粒子是否随GO移动而移动;Local随,World不随,Custom绑定其他GO</li></ul><h2 id="线段和拖尾-LineRenderer和TrailRenderer组件"><a href="#线段和拖尾-LineRenderer和TrailRenderer组件" class="headerlink" title="线段和拖尾: LineRenderer和TrailRenderer组件"></a>线段和拖尾: <code>LineRenderer</code>和<code>TrailRenderer</code>组件</h2><h2 id="旧动画-Animation组件"><a href="#旧动画-Animation组件" class="headerlink" title="旧动画: Animation组件"></a>旧动画: <code>Animation</code>组件</h2><ul><li><code>Culling Typ</code>: 是否一直播放动画</li><li>动画窗体: ctrl+6</li><li>使用类似AudioSource: Play(),animation clip</li></ul><h2 id="新动画-Animator组件"><a href="#新动画-Animator组件" class="headerlink" title="新动画: Animator组件"></a>新动画: <code>Animator</code>组件</h2><ul><li><code>Controller</code>: 由<code>AnimatorController.controller</code>资源文件控制</li><li><code>Culling Mode</code>: <code>Cull Update Transforms</code>表示不在镜头时暂停渲染, <code>Cull Completely</code>表示不在镜头时完全停止</li><li>在Window-Animation中创建不同的动画资源<code>.anim</code>文件, 在Window-Animator中作为不同的动画状态<code>State</code>进行管理</li><li><code>.controller</code>文件包含了三方面内容: <ul><li>对<code>.anim</code>文件的引用</li><li>对<code>.anim</code>文件的设置</li><li><code>.anim</code>文件之间的相互连接关系</li></ul></li></ul><h3 id="动画的构成-anim文件"><a href="#动画的构成-anim文件" class="headerlink" title="动画的构成: anim文件"></a>动画的构成: <code>anim</code>文件</h3><ul><li><code>Rig</code> - <code>Animation Type</code>: 动画类型<ul><li>无: 不包含动画</li><li><code>Legacy</code>旧版: 只能用<code>Animation</code>旧版动画组件</li><li><code>Generic</code>泛型: 新版动画, 各种非人动画</li><li><code>Humanoid</code>人型: 新版动画, 用于人</li></ul></li><li><code>Rig</code> - <code>Avatar</code>骨骼: 从模型或从其他地方</li><li><code>Animation</code>: 对动画Clip进行细操<ul><li><code>Loop Match</code>: 首位帧是否相似</li><li><code>Bake Into Pose</code>: 烘焙特定方向的位移, 避免在动画过程中发生位移</li><li><code>Curves</code>曲线: 随动画播放时间的函数曲线, 其值同步在<code>animator</code>的同名<code>parameters</code>中</li><li><code>Events</code>事件: 在动画的某一帧调用函数(如脚步踏地时发出脚步声)</li></ul></li><li><code>Blend Tree</code> in AnimatorWindowContext: 混合动画(如走和跑的混合)<ul><li><code>Blend Type</code>混合模式: 由几个变量控制混合动画的计算, 变量在<code>animator</code>的同名<code>parameters</code>中</li><li><code>Motion</code>: 选择混合的动画</li><li><code>Automate Thresholds</code>: 是否默认各个<code>Motion</code>的取值范围</li></ul></li><li><code>Sub-State Machine</code> in AnimatorWindowContext子状态机: 不同的动画状态的分组归类<ul><li>如拿枪到一个子状态中, 换刀到另一个子状态中</li></ul></li><li><code>Base Layer</code>: 动画状态图层<ul><li><code>Weight</code>:权重; <code>Mask</code>: Avatar骨骼遮罩; <code>IK</code>: 反向动力学效果;</li><li>不使用<code>Mask</code>可以通过控制 <code>Weight</code>获得同<code>Blend Tree</code>一样的效果, 使用<code>Mask</code>可以精确实现不同部位动画的混合</li></ul></li></ul><h2 id="导航系统-需要在PackageManagement中安装AI-Navigation组件"><a href="#导航系统-需要在PackageManagement中安装AI-Navigation组件" class="headerlink" title="导航系统(需要在PackageManagement中安装AI Navigation组件)"></a>导航系统(需要在PackageManagement中安装<code>AI Navigation</code>组件)</h2><h3 id="1-静态障碍物"><a href="#1-静态障碍物" class="headerlink" title="1.静态障碍物"></a>1.静态障碍物</h3><ul><li>首先将道路GO勾选为<code>Navigation Static</code>, 然后在选择Window - AI - Navigation设置烘焙; 接着将PlayerGO添加<code>NavMeshAgent</code>组件</li><li><code>Bake</code>: 烘焙Agent的半径, 高度, 可上最大坡度Slope, 台阶每一阶步高, 可掉落的高度, 可跳跃的距离. (可以添加多个Agent, 作为高矮胖瘦不同的人)</li><li><code>掉落高度</code>和<code>跳跃距离</code>是通过生成<code>OffMeshLinks</code>实现, 需要勾选需要生成links的障碍物GO的<code>Object</code> - <code>Generate OffMeshLinks</code></li><li><code>Area</code>: 不同区域的成本消耗设置, 在<code>Object</code> - <code>Navigation Area</code>中更改</li><li><code>Nav Mesh Agent</code>组件:<ul><li><code>Steering</code>: 位移相关<ul><li><code>Acceleration</code>: 加速度</li></ul></li><li><code>Obstacle Avoidance</code> - <code>Priority</code>: 一个路口多个Agent待通过时的优先级</li><li><code>Area Mask</code>区域遮罩: 特定区域永远不可通过, 用于针对不同Agent设定不同的禁止区域</li></ul></li><li>代码实现:<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//前面获取代理组件</span><br><span class="hljs-keyword">using</span> UnityEngine.AI;<br>NavMeshAgent agent = GetComponent&lt;NavMeshAgent&gt;();<br><br><span class="hljs-comment">//在Update方法中逐帧更新:</span><br><span class="hljs-keyword">if</span>(GetMouseButtonDown(<span class="hljs-number">0</span>))&#123;<br>  Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);<br>  RaycastHit hit;<br>  <span class="hljs-keyword">if</span>(Physics.Raycast(ray, <span class="hljs-keyword">out</span> hit)) <span class="hljs-comment">//从屏幕点击到3D位置坐标</span><br>  &#123; <br>    agent.SetDestination(<span class="hljs-keyword">new</span> Vector3(hit.point)); <span class="hljs-comment">//将坐标设为destination</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-动态障碍物"><a href="#2-动态障碍物" class="headerlink" title="2.动态障碍物"></a>2.动态障碍物</h3><ul><li>将特定的某些GO取消勾选<code>Navigation Static</code>, 并添加<code>NavMeshObstacle</code>组件<ul><li><code>Carve</code>切割: 勾选后会根据该GO的位移重新烘焙原有的静态障碍道路<ul><li><code>Move Threshold</code>移动阈值: 最小移动多远时开始rebake</li><li><code>Time to Stationary</code>静止时间: 移动阈值后经过多少秒开始rebake</li><li><code>Carve Only Stationary</code>仅在静止时切割: 取消后会随着位移即时rebake, 性能消耗较大</li></ul></li></ul></li></ul><h3 id="3-点对点定点传送-Off-Mesh-Link组件"><a href="#3-点对点定点传送-Off-Mesh-Link组件" class="headerlink" title="3.点对点定点传送: Off Mesh Link组件"></a>3.点对点定点传送: <code>Off Mesh Link</code>组件</h3><ul><li><code>Auto Update Position</code>: 当GO位置改变时, 即时更新<code>Link</code>; 如果位置不会改变就取消,以降低能耗</li></ul><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul><li><code>UI</code>由<code>Canvas</code>和<code>EventSystem</code>两个GO组成, <code>Canvas</code>为所有UI控件GO的父物体</li><li><code>Canvas</code>组件:<ul><li><code>Render Mode</code>: <ul><li><code>OverLay</code>: 永远在最上层</li><li><code>Camera</code>: 可被其他GO覆盖</li><li><code>World Space</code>: 在3D世界中的一层平面, 可旋转</li></ul></li><li><code>Sort Order</code>: 多个<code>Canvas</code>时的渲染优先级</li></ul></li><li><code>Image</code>组件:<br><code>Raycast Target</code>: 是否接收射线投射<br><code>Anchors</code>: 缩放参照锚点<br><code>Pivot</code>: 图片的轴心, 图片的旋转缩放坐标都是由轴心控制</li><li>字体: 新版更清晰, 富文本更多<ul><li><code>Color Gradient</code>: 颜色渐变</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/06/hello-world/"/>
    <url>/2024/02/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
