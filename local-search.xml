<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>做小生意真的比打工强吗？</title>
    <link href="/2024/02/13/%E5%81%9A%E5%B0%8F%E7%94%9F%E6%84%8F%E7%9C%9F%E7%9A%84%E6%AF%94%E6%89%93%E5%B7%A5%E5%BC%BA%E5%90%97%EF%BC%9F/"/>
    <url>/2024/02/13/%E5%81%9A%E5%B0%8F%E7%94%9F%E6%84%8F%E7%9C%9F%E7%9A%84%E6%AF%94%E6%89%93%E5%B7%A5%E5%BC%BA%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>本人在塞里斯十几年，虽然入职的是很高大上的单位，但我单位有大量的行业调研数据加上亲自ipc考察过许许多多小微生意，我觉得我很有发言权。<br><strong>我要来给你泼点凉水和熬点鸡汤。</strong><br><strong>既然是小生意，那我们首先排除什么大宗进出口，大型加工，大型工程 ，金融证券银行保险房地产等等这些技术密集，资本密集，最主要关系密集的玩意儿。</strong><br><strong>从你这个打工人实际能干的说起。</strong><br><strong>一</strong>，比如饭店和早餐摊位，我可以很明白告诉你，你没戏。<br>大饭店大酒店我们不谈，你肯定没戏，这既需要大量经验又需要资金支持还需要本地强力关系更要八面玲珑的会做人。<br>先谈有店面的小饭店，这里分三种，第一种，做家常炒菜，客人进来点几个菜的，这种店纯粹凭厨师个人技艺，你没戏，除非你有亲兄弟亲爹妈亲儿女当厨师那种，你想雇个厨师，这不可能，人性问题<br>第二种，特色单价菜品，比如地锅鸡，酸菜鱼，讲究一个锅子加点配菜能吃好久 ，厨房不用炒菜，能让上班族吹牛几小时，定价168以下，能做吗？做不了！ 首先你很难品控，其次就是地理位置，什么位置富集这种吹牛几小时下班来吃呢？这种位置的房东也早已心知肚明，基本沦落给房东打工<br>第三种，黄焖鸡米饭，沙县小吃，面馆等，同理，也是最后沦落到给房东打工<br>有店面的饭店，根本不用去算什么翻桌率，什么60毛利生死线，什么渠道进货，什么菜单，什么水电煤等等等 ，房东比你门清多了，除非你有个优秀厨师的亲人，就搞个小门头，不然活下来的都是给房东打工，活不下来的就是地理问题<br>那么不要店面的摆摊行不行？<br>更加不行，不在于吃苦吃累，而是黄金摊位你没资格摆，摆摊界也有江湖，你在写字楼门口摆个早饭摊是不现实的 ，不被掀掉是不可能的。<br><strong>二，奶茶店，咖啡店，小区咖啡店，民宿，小型电竞网吧</strong><br>必死无疑，绝对死翘翘，没有疑问的死翘翘，三大坑不是开玩笑的，不用好奇原理，保证死翘翘<br><strong>三，开小加工厂。</strong><br>必死无疑 ，毫无疑问，不用多想，开之前胸脯拍的通红的下游直接给你拉一年账期都有可能，称兄道弟的上游全是款到发货，工人，消防，厂房，物流发货，根本不是能随便应付的。而且这种厂会有很多错觉，订单一直有 ，好像垫垫资就能挺过去，银行也乐意放，最后借贷到倾家荡产，家破人亡。<br><strong>四，教培</strong><br><br>主课教培一来打击的严，二来纯靠口碑，纯口碑行业，很难搞。<br><br>美术，跳舞，画画，音乐等等也不是不行，主要也是房租问题，正规场地根本不可能，一堆未成年人挤一块的合法合规场地不是普通人能负担的<br>你得真有本事，并且是本地人，会聊会谈让家长信任，那么你搞个小场地也能赚，比打工会好一点吧，前提是你真有这方面的技能。你如果想着什么招老师，那我劝你省省。<br><strong>五，鲜花店，服装店，小卖部小超市水果店菜场</strong><br>前两个呢，二奶喜欢的，既然是二奶喜欢的你说那是来创业的嘛？那是来cos打发时间的一种情趣play。<br>当然也有能赚钱的鲜花店，那你得学会扫楼，学会不要脸的去搞渠道，要时间积累。赚钱的小服装店更是全靠老顾客，你这得相当会做人<br><br>至于小卖部小超市水果店菜场，跟饭店类似，不赚钱的有各种死法，赚钱的都是有里面的江湖，比如位置，比如优秀的进货渠道，而这又是要靠那么点关系，级别一点都不高的关系，可你不认识啊，关键是你不认识。<br><br><br><br>其余什么装修汽修开锁这种靠手艺吃饭的就不多说了，看你有没有这手艺吧。<br><br><br><br><strong>和大多数回答不一样的是，你自己对照一下上面，你有没有手艺？有没有关系？有没有渠道？没有的话老老实实呆着。</strong><br><br><br><br><br><br><br><br><strong>但我可以再给你来点鸡汤。</strong><br><br><strong>一，力推中医相关。</strong><br><strong>资格证去河南进修，那里突破口很大，你真想搞你自己去打听，河南那一定能搞定。</strong><br><strong>回来搞个中医馆，买本古汉语词典，读古文观止，词汇有点修养，搞吧，药丸里别搓现代药物进去就行，你就随便搞，别丧良心让人不打胰岛素不吃降压药就行，随便搞点什么，周边小区的退休资金能被你吸成漩涡。</strong><br>一年百万那是轻轻松松，而且完全合法。<br><strong>二 传媒相关。</strong><br>就拿二十万到五十万出来，租个十套公寓，精装的，偏远位置，两三万一个月差不多了，你就招广西云南那的小妹，大专的都不能要，中专初中肄业刚满十八那种，人要瘦，脸要小，腿要长，身上要有纹身。<br><br>你就画大饼，拼命画，丝袜吊带买足，你就搞直播，就搞，要会聊大哥，手机里十几个微信，你就聊，两三个月就能搞条稳定流水线出来，就真的赚，但我劝你洁身自好一点，也别拍那种纯涩视频发，就擦边就要礼物 ，红包都不收。<br><br><br><br>这两个都是很有前途的，有人看的话继续更，没人看算了。<br></p><p>转自<a href="https://www.zhihu.com/question/22394536/answer/3379509954">做小生意真的比打工强吗？ - 永远感恩的回答 - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>Career</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知乎</tag>
      
      <tag>打工</tag>
      
      <tag>小生意</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>民可使由之，不可使知之</title>
    <link href="/2024/02/12/%E6%B0%91%E5%8F%AF%E4%BD%BF%E7%94%B1%E4%B9%8B%EF%BC%8C%E4%B8%8D%E5%8F%AF%E4%BD%BF%E7%9F%A5%E4%B9%8B/"/>
    <url>/2024/02/12/%E6%B0%91%E5%8F%AF%E4%BD%BF%E7%94%B1%E4%B9%8B%EF%BC%8C%E4%B8%8D%E5%8F%AF%E4%BD%BF%E7%9F%A5%E4%B9%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>子曰：“兴于诗，立于礼，成于乐。”</p></blockquote><p>兴，兴起，起始。立，自立，立足于社会。成，完成。</p><p>诗，诗经，也可理解为基本的文学素养，包含识字、历史、音律、民俗等包罗万象的内容。礼，周礼，礼节，社会互动之基本规则。乐，音乐。</p><p>一个人，以学习文字的听说读写为起点；在成长过程中学习社会的经济制度、社会制度、文化制度，认识社会的运行、社交的礼仪，由此得以立足于社会；在此基础之上，遵循自身的兴趣和社会主流文化，选择并坚持自己的志趣，从而完成自我实现。<br><br></p><blockquote><p>子曰：“民可使由之，不可使知之。”</p></blockquote><p>这句话解读版本较多。</p><ul><li><p>愚民说（对君）：可以指导人（效法）做什么，但不可以让他知道为什么这么做。</p></li><li><p>君君说（对君）：对于民，让他效法君（的崇德做法）是可实现的（able），让他完全理解这些（但缺少君的以身作则）是困难的（unable）。（因此君应当以身作则。）</p></li></ul><p>还有联系上文一起理解：</p><ul><li>对于“兴于诗，立于礼，成于乐”这件事，如果民可以达到（accessible）就让（encourage to follow）他这么做（this way），如果不能达到就让他知道（子孙／其他人）应该这么做。这一说法的立足之处在于其符合克己复礼的主张。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过量补充维生素B的副作用</title>
    <link href="/2024/02/10/%E8%BF%87%E9%87%8F%E8%A1%A5%E5%85%85%E7%BB%B4%E7%94%9F%E7%B4%A0B%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/"/>
    <url>/2024/02/10/%E8%BF%87%E9%87%8F%E8%A1%A5%E5%85%85%E7%BB%B4%E7%94%9F%E7%B4%A0B%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="过量补充维生素B的副作用"><a href="#过量补充维生素B的副作用" class="headerlink" title="过量补充维生素B的副作用"></a>过量补充维生素B的副作用</h2><ul><li>过量补充维生素B1（每天服用剂量超过5g），可能会引起心跳加快，发抖，疱疹，浮肿，过敏等副作用。</li><li>过量补充维生素B2，可能会引起感觉异常，比如瘙痒，刺痛等症状。服用维生素B2后，可能会出现尿液呈亮黄色的现象，这种情况不必担心，是药物排泄的正常颜色，停药后即可恢复。</li><li>过量服用维生素B3（烟酸），会出现皮肤潮红、瘙痒，胃痛恶心等消化道症状，肝功能异常以及视物模糊等症状。另外，维生素B3还会影响尿酸的排泄，高尿酸患者应该慎用补充剂。</li><li>补充维生素B6（吡哆醇）过量，可以导致神经系统出现问题，甚至可能导致皮肤感觉丧失。</li><li>过量补充维生素B9（叶酸），会掩盖维生素B12缺乏的问题，导致神经或血液系统出现问题，同时过量补充叶酸，还有可能影响锌的吸收。</li><li>过量补充维生素B12，会导致心悸、心前区疼痛等心血管症状，同时还有可能出现皮疹、哮喘、寒颤等过敏症状，还可能导致叶酸的缺乏。</li></ul><h2 id="【补充知识】"><a href="#【补充知识】" class="headerlink" title="【补充知识】"></a>【补充知识】</h2><h3 id="一、维生素B介绍"><a href="#一、维生素B介绍" class="headerlink" title="一、维生素B介绍"></a>一、维生素B介绍</h3><p>维生素是人体所需的一大类营养素，而B族维生素就是其中的重要一类。之所以称之为“族”，是因为不同于维生素A、维生素C等具有固定结构的维生素，这类维生素是一大类水溶性维生素的总称。</p><p>在B族维生素中，我们常见的有维生素B1，维生素B2，维生素B3（烟酸），维生素B5（泛酸），维生素B6（吡哆醇），维生素B9（叶酸），维生素B12（钴胺素）等多种。</p><h3 id="二、B族维生素共同点"><a href="#二、B族维生素共同点" class="headerlink" title="二、B族维生素共同点"></a>二、B族维生素共同点</h3><ol><li>其理化特性上有一定的相似性。所有的B族维生素都是水溶性的维生素，因此难以在人体内大量贮存，通常可通过汗液、尿液等体液排出。</li><li>其生理功能有相互交叉。在营养身体的神经系统、维持造血功能，改善身体代谢能力，维护皮肤黏膜健康等方面，B族维生素都发挥着重要的作用。</li><li>相互之间有一定的协同作用。只有全面的保持各种营养的均衡充足，才能够更好的发挥其生理功能。比如维生素B2的缺乏，会影响维生素B6的吸收和利用。</li></ol><h3 id="三、补充维生素B的建议"><a href="#三、补充维生素B的建议" class="headerlink" title="三、补充维生素B的建议"></a>三、补充维生素B的建议</h3><ol><li>通常情况下，每日从饮食中摄入的B族维生素能够满足人体所需，没有必要服用额外的补充剂。在我们的日常膳食中，B族维生素可以说来源还是非常多的，不管是谷物、豆类，还是动物内脏，不管是蔬菜，还是各种水果，不管是蛋黄还是肉类，其中都含有各种各样的B族维生素，如果能够在日常生活中能够保持均衡营养的合理膳食，是不会缺乏维生素B的。</li><li>如果身体确实存在缺乏B族维生素的情况，也可以在日常膳食以外，通过服用补充剂来补充B族维生素。比如缺乏维生素B1导致的脚气病，缺乏维生素B2导致的口唇炎、阴部瘙痒等问题，叶酸摄入不足导致的血同型半胱氨酸偏高等问题，前提是要确定确实缺乏，必要时可咨询医生、采取血液检查。</li><li>建议选择价格便宜量又足的“药字号”产品。比如最常见的复合维生素B片，里面含有维生素B1，B2，B3，B5，B6，一瓶100片只要几元钱，是补充B族维生素的好选择。不建议选择价格高昂，质量还不一定有保证的保健品。包装上印着“国药准字H****”的，就是药字号产品。</li><li>对于B族维生素的补充，一是要强调针对性：缺什么？缺多少？缺哪种，就可以服用补充剂适量补充。虽然B族维生素长期服用通常安全性也较高，其水溶性的特性也会使过量补充的B族维生素通过尿液排出体外，但过量补充B族维生素同样可能产生不良反应风险。</li></ol><details><summary>文章来源</summary><li>原网页</li><a href="https://www.cn-healthcare.com/articlewm/20200427/content-1108223.html">维生素B适量补充很重要，医生提醒：过量补充，6种不良反应要注|导致|维生素|-健康界</a><li>网页快照（2023.03.09）</li><img src="https://pic2.zhimg.com/v2-44b385a444e188664414c42167a802f1_r.jpg" alt="网页快照"></details><p>本文转自 <a href="https://zhuanlan.zhihu.com/p/612640750">https://zhuanlan.zhihu.com/p/612640750</a>，如有侵权，请联系删除。</p>]]></content>
    
    
    <categories>
      
      <category>Health</category>
      
    </categories>
    
    
    <tags>
      
      <tag>维生素B</tag>
      
      <tag>维生素</tag>
      
      <tag>过量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity1 - Gamer羽飞</title>
    <link href="/2024/02/08/unity1/"/>
    <url>/2024/02/08/unity1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol><li>一定要多练习</li><li>扩展发散</li><li>学完后尝试建立自己的游戏框架</li></ol><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="场景区"><a href="#场景区" class="headerlink" title="场景区"></a>场景区</h3><ul><li>中键: 同Q</li><li>右键+wasd: 作为player移动</li><li>Alt+左键: 转动视角</li><li>E: 旋转Rotate</li><li>R: 缩放Scale</li><li>T: 矩形缩放Rect，只管一个平面矩形的缩放，一般用于2D平面，如UI</li><li>Y: 全都有</li></ul><h2 id="Game-Object"><a href="#Game-Object" class="headerlink" title="Game Object"></a>Game Object</h2><ul><li>Sphere平面和Quad矩形的区别<ul><li>Sphere三角面更多, 可以支撑更精确复杂的计算; Quad三角面只有两个</li><li>Sphere一般没有y, Quad一般没有z</li></ul></li><li>不同GO的本质区别在于不同GO的Mesh Filter组件中Mesh属性的取值不同</li></ul><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><ul><li>在C#中通过Transform实例化的对象来访问对象本身的Position，Rotation变量是世界坐标系下的值。<br><code>transform.position; transform.rotation;</code></li><li>若想获取与组件上的本地坐标则应访问<code>transform.localPosition</code>和<code>transform.localRotation</code></li><li>从世界坐标转成相对父对象的局部坐标: <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">transform.TransformPoint(transform.localPosition);<br><span class="hljs-comment">//局部坐标转世界坐标</span><br>transform.parent.InverseTransformPoint(transform.position);<br><span class="hljs-comment">//世界坐标转局部坐标</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="游戏资源管理"><a href="#游戏资源管理" class="headerlink" title="游戏资源管理"></a>游戏资源管理</h2><ul><li>导入导出包UnityPackageFile: unity自身的一个压缩包</li><li>fbx: 3D模型文件</li><li>默认Material材质不可更改, 更改需要新建一个Material并应用到对应的GO上. 通过GO的MeshRenderer组件中Material组件可以添加各自的Material, 不同的Material通过选定的Shader着色器(默认Standard)渲染到GO上. </li><li>Window-&gt;Package Manager管理在Assets Store下载的资源包</li></ul><h2 id="Terrain地形"><a href="#Terrain地形" class="headerlink" title="Terrain地形"></a>Terrain地形</h2><ol><li>添加相邻地形</li></ol><ul><li>FillHeightmapUsing: 连接地形的方法<ul><li>clamp: 相邻瓦片交叉混合</li><li>mirror: 镜像</li></ul></li></ul><ol start="2"><li>绘制地形<blockquote><p>Opacity: 不透明度</p></blockquote></li></ol><ul><li>Paint Holes: 镂空画洞</li><li>Set Height: 设置高度<ul><li>Flatten Tile: 展平当前terrain</li><li>Flatten All: 展平所有terrain</li></ul></li><li>Smooth Height: 平滑高度<ul><li>Blur Direction: 仅向下舍去-1,双向0,仅向上进入1</li></ul></li><li>Stamp Terrain: 只能点一下, 不能滑动绘制</li><li>Paint Texture: 绘制纹理<ul><li>在Terrain Layer中选择Texture资源<blockquote><p>Tips: 一般不用绘制, 只需要了解</p></blockquote></li></ul></li></ul><ol start="3"><li>画树</li></ol><ul><li>Mass Place Tree: 大量放置树</li></ul><ol start="4"><li>绘制细节</li></ol><ul><li>Add Grass Texture: 给地面添加草<ul><li>最终强度: 草的密集程度</li></ul></li></ul><ol start="5"><li>地形设置</li></ol><h2 id="脚本的生命周期"><a href="#脚本的生命周期" class="headerlink" title="脚本的生命周期"></a>脚本的生命周期</h2><p>![Unity官方图解](D:\Program Files\Typora\assets\unity1\f366aa7d27e1514bb579b495f09942bf.png)</p><ol><li><p>Awake：初始化时调用，通常使用为需要提前初始化的逻辑。比如单例赋值<code>private void Awake()&#123;Instance = this;&#125;</code></p></li><li><p>OnEnable：在对象启用时调用，处理每次显示时都需要进行初始化的逻辑，通常和OnDisable配合使用。<br>比如: 游戏逻辑使用并修改了变量<code>Number</code>，而下次显示时使用是又需要<code>Number = 1</code>，此时就可以写<code>private void Awake()&#123;Number = 1;&#125;</code></p></li><li><p>Start：仅当启用脚本实例时，才会在第一帧调用。通常使用为一些变量初始化逻辑。比如：获取指定物体：<code>private void Start()&#123;child1 = transform.GetChild(0);&#125;</code></p></li><li><p>Fixed Update：固定时间调用，所有物理计算和更新都在Fixed Update中处理，不受帧率影响。比如：一些物理属性的更新操作Force，Collider，Rigidbody等。</p></li><li><p>Update：每帧调用一次，根据帧率的快慢影响执行速度。通常的游戏逻辑都写在这里，比如：和玩家交换，当用户按下空格时进行执行什么操作。</p></li><li><p>LateUpdate：在Update完成后，每帧调用一次。常见用处是相机跟随主角，比如：主角在Update中移动，则可以在LateUpdate执行相机的移动，这将可以保证摄像机跟着的时候之前的逻辑一起完全执行完成。</p></li><li><p>OnMouseXXX: 通过鼠标的射线检测来判断鼠标当前位置是否碰到了挂载脚本游戏对象的碰撞体。</p><ul><li><p>前提：</p><ul><li>只能检测当前脚本挂载的游戏对象。</li><li>当前游戏对象需要有碰撞体。</li><li>不能有其他物体(UI)遮挡到此游戏对象。</li></ul></li><li><p>函数：</p><ul><li>OnMouseEnter: 鼠标进入时调用一次</li><li>OnMouseOver: 鼠标停留(经过)时一直调用</li><li>OnMouseExit: 鼠标退出时调用一次</li><li>OnMouseDown: 鼠标按下时调用一次</li><li>OnMouseDrag: 鼠标拖拽(按住)时一直调用</li><li>OnMouseUp: 鼠标抬起时调用一次</li></ul></li><li><p>应用（一般成对使用）：</p><ul><li>OnMouseEnter，OnMouseOver，OnMouseExit 一组。比如模拟选中状态：鼠标进入时物体变色，鼠标退出时再变回来。</li><li>OnMouseDown，OnMouseDrag，OnMouseUp 一组。比如射击游戏：鼠标按下拖拽时调整方向，抬起时发射子弹。</li><li>当鼠标按下并停留在当前游戏对象上时，OnMouseOver，OnMouseDrag会同时触发。</li></ul></li></ul></li><li><p>OnTriggerXX:</p><ul><li><p>函数</p><ul><li>OnCollisionEnter: 进入碰撞时触发一次。</li><li>OnCollisionStay: 在碰撞体中停留时每帧触发一次。</li><li>OnCollisionExit: 离开碰撞体时触发一次。</li><li>OnTriggerEnter: 进入碰撞体时触发一次。</li><li>OnTriggerStay: 在碰撞体中停留时每帧触发一次。</li><li>OnTriggerExit: 离开碰撞体是触发一次。</li></ul><blockquote><p>还有对应2D碰撞体的六个方法（如：<code>OnCollisionEnter2D</code>） 函数后面添加2D接口，触发条件和使用方式和3D一致。 使用时注意碰撞体和检测函数同步接口，即用2D碰撞体必须用2D函数。</p></blockquote></li><li><p>前提同上</p></li></ul></li><li><p>OnApplicationXX:</p><ul><li>函数:<ul><li>OnApplicationPause: 检测到暂停的帧结束 –&gt; 切换到后台和回来时调用。游戏停止保存数据&#x2F;游戏继续数据初始化。</li><li>OnApplicationFocus: 当屏幕 获得&#x2F;失去 焦点时调用。失去焦点关闭背景音乐&#x2F;获得焦点继续播放音乐。</li><li>OnApplicationQuit: 当程序退出时调用。在移动端大退时也会对调用，但不会触发上面两个方法。</li></ul></li></ul></li><li><p>禁用与销毁</p><ul><li><code>OnDisable</code>: 当对象被禁用时调用此函数（其父物体被禁用也会触发）。通常和OnEnable配合使用。比如：在OnEnable添加监听，在OnDisable移除监听</li><li><code>OnDestroy</code>: 在对象存在的最后一帧的所有帧更新之后调用此函数。当物体销毁或者场景关闭时触发。比如：子弹打到墙壁时，需要销毁子弹并触发一个打击音效。</li></ul></li></ol><h2 id="脚本执行顺序"><a href="#脚本执行顺序" class="headerlink" title="脚本执行顺序"></a>脚本执行顺序</h2><ul><li><p>先执行所有的<code>Awake()</code>, 再执行所有的<code>Start()</code></p></li><li><p>Execution Order中设置cs脚本执行顺序, 数值越小越先执行</p></li></ul><h2 id="标签和图层"><a href="#标签和图层" class="headerlink" title="标签和图层"></a>标签和图层</h2><ul><li>给GO分组的工具</li><li>图层可以在Camera组件Culling Mask属性中选择遮罩图层, 实现显隐不同图层的功能</li></ul><h2 id="Prefab预制体与变体"><a href="#Prefab预制体与变体" class="headerlink" title="Prefab预制体与变体"></a>Prefab预制体与变体</h2><ul><li><p>以.prefab文件存储的GO, 可以通过GO快速创建别人打包好的GO</p></li><li><p>在Scene中的GO组件发生改变, 可以通过右键组件应用到Prefab文件的修改</p></li><li><p>通过预制体创建的GO发生大改变, 将GO独立为新的prefab时, 选择<code>原始预制体</code>将保留对原始预制体的引用, 选择<code>预制体变体</code>将不再保留对原始预制体的引用</p></li><li><p>通过代码来创建GO就可以考虑使用预制体</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> GameObject sphere; <span class="hljs-comment">//首先public一个GO变量, 然后在unity面板中拖入特定的预制体</span><br>Instantiate(sphere,transform); <span class="hljs-comment">//使用Instantiate初始化这个变量, 并将其设置为当前GO的子GO.该函数返回值为go对象</span><br>Destroy(Instantiate(sphere,transform)); <span class="hljs-comment">//创建并销毁go</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="Vector3"><a href="#Vector3" class="headerlink" title="Vector3"></a>Vector3</h2><ul><li><p>常用常量</p><ul><li><p><code>Vector3.zero</code>: (0,0,0)</p></li><li><p><code>Vector3.one</code>: (1,1,1)</p></li></ul></li><li><p>函数</p><ul><li><p><code>Vector3.Angle(new Vector3(0,0,0),new Vector3(1,1,1))</code>: 两个向量之间的夹角</p></li><li><p><code>Vector3.Distance(new Vector3(0,0,0),new Vector3(1,1,1))</code>: 两个坐标之间的距离</p></li><li><p><code>Vector3.Dot(new Vector3(0,0,0),new Vector3(1,1,1))</code>: 两个向量的乘积(返回&#x3D;&#x3D;标量&#x3D;&#x3D;)</p><blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//Dot源码</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">float</span> <span class="hljs-title">Dot</span>(<span class="hljs-params">Vector3 lhs, Vector3 rhs</span>)</span><br>&#123;<br> <span class="hljs-keyword">return</span> lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>a</strong>⋅<strong>b</strong>&#x3D;(x<del>1</del>,y<del>1</del>,z<del>1</del>)⋅(x2,y2,z2)&#x3D;x1×x2+y1×y2+z1×z2&#x3D;|<strong>a</strong>|×|<strong>b</strong>|×<em>cos</em>θ</p><p>通过<strong>取值正负</strong>可以判断两向量<strong>方向是否相同</strong>; 通过<strong>取值是否为0</strong>可以判断<strong>是否垂直</strong></p></blockquote></li><li><p><code>Vector3.Cross(new Vector3(0,0,0),new Vector3(1,1,1))</code>: 两个向量的叉乘(返回&#x3D;&#x3D;Vector3对象&#x3D;&#x3D;)</p><blockquote><p>&#x2F;&#x2F;Cross源码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector3 <span class="hljs-title">Cross</span>(<span class="hljs-params">Vector3 lhs, Vector3 rhs</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>a</strong>×<strong>b</strong>&#x3D;(a1,a2,a3)×(b1,b2,b3)&#x3D;(a2×b3−a3×b3,a3×b1−a1×b3,a1×b2−a2×b1))</p><p>|<strong>a</strong>×<strong>b</strong>|&#x3D;|<strong>a</strong>|×|<strong>b</strong>|×sinβ</p><p>叉乘的几何意义表示为求得以<strong>a</strong>和<strong>b</strong>为平面的法线向量<strong>c</strong>, <strong>c</strong>⊥<strong>a</strong>与<strong>b</strong>组成的平面, <strong>c</strong>的模|<strong>c</strong>|&#x3D;|<strong>a</strong>|×|<strong>b</strong>|×sinβ, 或以<strong>a</strong>和<strong>b</strong>组成的平行四边形的面积</p><p>若两者叉乘之模为0, 则<strong>a</strong>与<strong>b</strong>相互平行; 若两者叉乘之模等于两者各自的模的乘积, 则<strong>a</strong>与<strong>b</strong>相互垂直</p></blockquote></li><li><p><code>Vector3.Lerp(new Vector3(0,0,0),new Vector3(1,1,1),0.5f)</code>: 两个Vector3之间插值</p></li></ul></li><li><p>对象常量(<code>Vector3 v = new Vector3(1,1,1);</code>)</p><ul><li><code>v.magnitude</code>: Vector3的模</li></ul></li></ul><h2 id="Euler欧拉角与Quaternion四元数"><a href="#Euler欧拉角与Quaternion四元数" class="headerlink" title="Euler欧拉角与Quaternion四元数"></a>Euler欧拉角与Quaternion四元数</h2><ul><li><p>Euler的实例化: 同Vector3</p><p><code>Vector3 rotate = new Vector3(0,30,0);</code></p></li><li><p>Quaternion的实例化: </p><ul><li>常量(0,0,0,0): <code>Quaternion.identity</code></li><li>欧拉角to四元数: <code>Quaternion quaternion = Quaternion.Euler(new Vector3(0,30,0));</code></li><li>四元数to欧拉角: <code>Vector3 vector3 = quaternion.eulerAngles;</code></li></ul></li></ul><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><ul><li>输出文本Text: <ul><li>调试输出: <code>Debug.log(&quot;Text&quot;);</code></li><li>调试输出警告: <code>Debug.logWarning(&quot;Text&quot;);</code></li><li>调试输出错误: <code>Debug.logError(&quot;Text&quot;);</code></li></ul></li><li>画线<ul><li>画直线: <code>Debug.DrawLine(Vector3.zero,Vector3.one,[Color.Green]); //两个必需参数为两个点坐标</code></li><li>画射线: <code>Debug.DrawRay(Vector3.zero,Vector3.one,[Color.Green]); //第一个参数是起始点坐标, 第二个参数为射线向量</code></li></ul></li></ul><h2 id="组件属性的修改"><a href="#组件属性的修改" class="headerlink" title="组件属性的修改"></a>组件属性的修改</h2><ul><li><p>获取GO和transform: </p><ul><li><p>获取本GO: <code>GameObject go = this.gameObject;</code> 也可直接使用<code>gameObject</code>代替<code>this.gameObject</code> </p><blockquote><p>GO的父子关系控制在<code>transform</code>组件中, 上面的<code>this</code>表示的是本<code>GO</code>的<code>transform</code>, 所以上面的<code>this.gameObject</code>也可以写为<code>transform.gameObject</code></p></blockquote></li><li><p>获取其他无关GO: </p><ul><li><p><code>public GameObject go;</code> 然后通过unity面板选择</p></li><li><p><code>GameObject.Find(&quot;name&quot;)</code>; 使用<code>GameObject</code>类方法根据name寻找</p></li><li><p><code>GameObject.FindWithTag(&quot;tag&quot;)</code>; 使用<code>GameObject</code>类方法根据tag寻找</p></li></ul></li><li><p>获取父物体GO:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">Transform parent = transform.parent; <span class="hljs-comment">// 获取物体的直接父物体</span><br>Transform root = transform.root; <span class="hljs-comment">// 获取物体的根物体</span><br><span class="hljs-built_in">int</span> hierarchy = transform.GetSiblingIndex(); <span class="hljs-comment">// 获取物体在父物体中的层级索引.根物体的层级索引为0，其直接子物体的层级索引依次递增</span><br></code></pre></td></tr></table></figure></li><li><p>获取子物体GO: </p><ul><li>获取所有层级所有子物体, 包括本物体: <code>GetComponentsInChildren()</code></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">Transform[] myTransforms = GetComponentsInChildren&lt;Transform&gt;();<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> child <span class="hljs-keyword">in</span> myTransforms)&#123;Debug.Log(child.name);&#125;<br></code></pre></td></tr></table></figure><ul><li><p>通过name获取<strong>一级</strong>子物体: <code>transform.Find(&quot;Child0&quot;)</code></p><blockquote><p>获取<strong>二级</strong>子物体需要<strong>全路径</strong>: <code>transform.Find(&quot;Child0/Child00&quot;)</code></p><p>&#x3D;&#x3D;注意: 对象<code>gameObject</code>没有此方法, <code>transform</code>有此方法, <code>transform</code>对象的方法只能寻找本身及子物体, <code>GameObject</code>类方法是从所有层级所有物体中寻找&#x3D;&#x3D;</p></blockquote></li><li><p>通过index获取一级子物体: <code>transform.GetChild(1)</code></p><blockquote><p>获取<strong>二级</strong>子物体需要<strong>连续两次调用</strong>: <code>transform.GetChild(1).GetChild(0)</code></p></blockquote></li></ul></li><li><p><code>GameObject</code>类的实例化需要到unity面板中选择, 在代码中的<code>gameObject</code>是<code>transform</code>对象的一个属性, 获得的所有父子GO物体均为相应的<code>transform</code>对象</p></li></ul></li><li><p>GO&#x2F;transform的属性和函数: </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#">go.name<br>go.tag<br>go.layer<br>go.activeInHierarchy <span class="hljs-comment">//是否激活状态在层级中</span><br>go.activeSelf <span class="hljs-comment">//本身是否激活状态</span><br><span class="hljs-comment">//两个同时为真才是激活状态, 只要有一个为假就不是激活状态</span><br>go.AddComponent&lt;BoxCollider&gt;(); <span class="hljs-comment">//添加组件</span><br>go.SetActive(<span class="hljs-literal">true</span>); <span class="hljs-comment">//设置是否激活, 这是go的函数, transform无法管控GO是否激活</span><br></code></pre></td></tr></table></figure></li><li><p>获取其他组件: <code>BoxCollider bc = GetComponent&lt;BoxCollider&gt;();</code>或直接使用匿名函数接想用的属性<code>GetComponent&lt;BoxCollider&gt;().xxx</code></p></li><li><p>获取父物体的特定组件: <code>GetComponentInParent&lt;BoxCollider&gt;()</code></p></li><li><p>获取子物体的特定组件: <code>BoxCollider[] bc = GetComponentInChidren&lt;BoxCollider&gt;()</code>, 会遍历包含本身在内的所有层级所有子物体</p></li></ul><h2 id="Time类"><a href="#Time类" class="headerlink" title="Time类"></a>Time类</h2><ol><li><p>Time类属性</p><table><thead><tr><th>总时间</th><th></th></tr></thead><tbody><tr><td><code>Time.time</code></td><td>帧时间</td></tr><tr><td><code>Time.unscaledTime</code></td><td>不受Scale约束的帧时间</td></tr><tr><td><code>Time.fixedTime</code></td><td>频率时间&#x2F;不受帧约束的时间</td></tr><tr><td><code>Time.unscaledFixedTime</code></td><td>不受Scale约束的频率时间</td></tr><tr><td><code>Time.realtimeSinceStartup</code></td><td>不受Scale影响的实际时间</td></tr><tr><td><code>Time.timeSinceLevelLoad</code></td><td>自最后一个非添加场景（non-additive scene）完成加载以来的Scaled时间</td></tr><tr><td><strong>增量时间</strong></td><td></td></tr><tr><td><code>Time.deltaTime</code></td><td>帧间隔时间&#x2F;Δ帧时间</td></tr><tr><td><code>Time.unscaledDeltaTime</code></td><td>不受Scale约束的帧间隔时间</td></tr><tr><td><code>Time.fixedDeltaTime</code></td><td>频率间隔时间&#x2F;不受帧约束的时间间隔</td></tr><tr><td><code>Time.fixedUnscaledDeltaTime</code></td><td>不受Scale约束的频率间隔时间</td></tr><tr><td><strong>其他</strong></td><td></td></tr><tr><td><code>Time.frameCount</code></td><td>总帧数</td></tr><tr><td><code>Time.timeScale</code></td><td>时间缩放尺度, 默认为1, 为0停止, 为2二倍速</td></tr><tr><td><code>Time.maximumDeltaTime</code></td><td>最大帧增量时间</td></tr><tr><td><code>Time.maximumParticleDeltaTime</code></td><td>粒子更新的最大帧增量时间</td></tr></tbody></table><ul><li>过于卡顿时, <code>Time.deltaTime</code>会增大, 但不会无限增大, 受<code>Time.maximumDeltaTime</code>限制, 而<code>Time.unscaledDeltaTime</code>不受此限制, 因此<code>Time.time</code>会比<code>Time.unscaledTime</code>慢一些.</li></ul></li></ol><h2 id="Application类"><a href="#Application类" class="headerlink" title="Application类"></a>Application类</h2><table><thead><tr><th>静态变量</th><th></th></tr></thead><tbody><tr><td><code>Application.persistentDataPath</code></td><td>不同平台持久化的Assets文件夹(读写)</td></tr><tr><td><code>Application.streamingAssetsPath</code></td><td>游戏安装目录Assets目录中<code>streamingAssets</code>文件夹, 无加密(只读)</td></tr><tr><td><code>Application.temporaryCachePath</code></td><td>临时文件夹</td></tr><tr><td><code>Application.runInBackground</code></td><td>是否在后台运行</td></tr><tr><td><code>Application.platform</code></td><td>返回游戏运行平台(只读)</td></tr><tr><td><code>Application.systemLanguage</code></td><td>返回系统语言(只读)</td></tr><tr><td><code>Application.unityVersion</code></td><td>返回unity版本</td></tr><tr><td><strong>静态函数</strong></td><td></td></tr><tr><td><code>Application.OpenURL(&quot;http&quot;)</code></td><td>打开URL</td></tr><tr><td><code>Application.Quit</code></td><td>退出游戏</td></tr></tbody></table><h2 id="Scene类与SceneManagement类"><a href="#Scene类与SceneManagement类" class="headerlink" title="Scene类与SceneManagement类"></a><code>Scene</code>类与<code>SceneManagement</code>类</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> UnityEngine.SceneManagement <span class="hljs-comment">//引入namespace使用SceneManager类</span><br>SceneManager.LoadScene(<span class="hljs-number">1</span>); <span class="hljs-comment">//在File-BildSettings中引入不同scene获得index, 通过index加载scene</span><br>SceneManager.LoadScene(<span class="hljs-string">&quot;MyScene&quot;</span>,[defalt:LoadSceneMode.Single]LoadSceneMode.Addictive); <span class="hljs-comment">//通过name加载scene</span><br>SceneManager.UnloadSceneAsync(s); <span class="hljs-comment">//卸载scene</span><br><br>Debug.log(SceneManager.sceneCount); <span class="hljs-comment">//数量</span><br><br>Scene s = SceneManager.GetActiveScene(); <span class="hljs-comment">//当前活动scene</span><br>Scene s = SceneManager.CreateScene(<span class="hljs-string">&quot;MyScene&quot;</span>); <span class="hljs-comment">//创建scene</span><br><br>Debug.log(s.name); <span class="hljs-comment">//名字</span><br>Debug.log(s.isLoaded); <span class="hljs-comment">//是否已加载</span><br>Debug.log(s.path); <span class="hljs-comment">//文件路径</span><br>Debug.log(s.buildIndex); <span class="hljs-comment">//获取index</span><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//异步加载场景需要用IEnumerator协程:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTest</span>:<span class="hljs-title">Monobehavior</span><br>&#123;<br>    AsyncOperation o; <span class="hljs-comment">//实例化一个AsyncOperation对象用以记录加载过程信息</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        StartCoroutine(loading()); <span class="hljs-comment">//使用StartCoroutin()启动协程, 参数为协程函数名</span><br>    &#125;<br>    <br>    <span class="hljs-function">IEnumerator <span class="hljs-title">loading</span>() <span class="hljs-comment">//定义协程事件</span></span><br>    &#123;<br>        o = SceneManager.LoadSceneAsync(<span class="hljs-string">&quot;MyScene&quot;</span>/<span class="hljs-number">1</span>); <span class="hljs-comment">//在协程中使用异步加载场景函数, 函数返回值为AsyncOperation类对象</span><br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> o; <span class="hljs-comment">//将加载过程的信息写入o中</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        Debug.log(o.progress); <span class="hljs-comment">//0-0.9</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Transform类"><a href="#Transform类" class="headerlink" title="Transform类"></a>Transform类</h2><table><thead><tr><th>实例变量</th><th></th></tr></thead><tbody><tr><td><code>transform.position</code></td><td>世界位置</td></tr><tr><td><code>transform.localPosition</code></td><td>相对位置</td></tr><tr><td><code>transform.rotation</code></td><td>世界旋转四元数</td></tr><tr><td><code>transform.localRotation</code></td><td>相对旋转四元数</td></tr><tr><td><code>transform.eulerAngles</code></td><td>世界旋转欧拉角</td></tr><tr><td><code>transform.localEulerAngles</code></td><td>相对旋转欧拉角</td></tr><tr><td><code>transform.localScale</code></td><td>缩放</td></tr><tr><td><code>transform.forward</code></td><td>GO的前后左右上下</td></tr><tr><td><strong>实例函数</strong></td><td></td></tr><tr><td><code>transform.LookAt(Vector3.zero)</code></td><td>一直看向某一个点(点坐标)</td></tr><tr><td><code>transform.Rotate(Vector3.up)</code></td><td>旋转(方向向量)</td></tr><tr><td><code>transform.Translate(Vector3.forward * 50 * Time.deltaTime)</code></td><td>向(0,0,1)移动(方向向量)</td></tr></tbody></table><h2 id="Input类"><a href="#Input类" class="headerlink" title="Input类"></a>Input类</h2><ol><li><p>按键Key</p><table><thead><tr><th>静态属性</th><th></th></tr></thead><tbody><tr><td><code>Input.anyKey</code></td><td>如果用户按下任何键(包含任意设备任意输入)，在按住不放的过程中一直返回true（只读）</td></tr><tr><td><code>Input.anyKeyDown</code></td><td>按下任何键(包含任意设备任意输入),按下的那一帧返回true(只读),之后的帧即使仍然被按住也返回false</td></tr><tr><td><code>Input.inputString</code></td><td>按下的键的值(配合<code>anyKey</code>实现自定义按键)</td></tr><tr><td><strong>静态方法</strong></td><td></td></tr><tr><td><code>Input.GetKey(KeyCode)</code></td><td>检测是否按下了任何指定键,一直按住则一直返回 true</td></tr><tr><td><code>Input.GetKeyDown(KeyCode)</code></td><td>检测是否按下了任何指定键,只有那一帧时true</td></tr><tr><td><code>Input.GetKeyUp(KeyCode)</code></td><td>释放的那一帧返回true</td></tr></tbody></table></li><li><p>按钮Button</p><table><thead><tr><th><strong>静态方法</strong></th><th></th></tr></thead><tbody><tr><td><code>Input.GetButton(string buttonName)</code></td><td>检测是否按下了任何按钮,一直按住则一直返回 true</td></tr><tr><td><code>Input.GetButtonDown()</code></td><td>检测是否按下了任何button,只有那一帧时true</td></tr><tr><td><code>Input.GetButtonUp()</code></td><td>释放的那一帧返回true</td></tr></tbody></table></li><li><p>鼠标</p><table><thead><tr><th>静态属性</th><th></th></tr></thead><tbody><tr><td><code>Input.mousePresent</code></td><td>是否有mouse设备连接（只读）</td></tr><tr><td><code>Input.mousePosition</code></td><td>当前鼠标位置(只读), z&#x3D;0, 左下角是(0,0,0), 右上角是分辨率</td></tr><tr><td><code>Input.mouseScrollDelta</code></td><td>鼠标滚轮滚动量(只读), 返回<code>Vector2</code>, y逆时针(0,1), 顺时针(0,-1)</td></tr><tr><td><strong>静态方法</strong></td><td></td></tr><tr><td><code>Input.GetMouseButton(int button)</code></td><td>检测是否按下了按钮,一直按住则一直返回 true, 0左键 1右键 2中键</td></tr><tr><td><code>Input.GetMouseButtonDown()</code></td><td>检测是否按下,只有那一帧时true</td></tr><tr><td><code>Input.GetMouseButtonUp()</code></td><td>释放的那一帧返回true</td></tr></tbody></table></li><li><p>虚拟轴</p><ul><li>设置内容在<code>编辑-ProjectSettings</code>中</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">float</span> h = Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>); <span class="hljs-comment">//获取水平轴(-1,1)</span><br><span class="hljs-built_in">float</span> v = Input.GetAxis(<span class="hljs-string">&quot;Vertical&quot;</span>);<br><span class="hljs-built_in">float</span> x = Input.GetAxis(<span class="hljs-string">&quot;Mouse X&quot;</span>); <span class="hljs-comment">//获取鼠标横向从移动, 左-1</span><br></code></pre></td></tr></table></figure><p><code>Input.GetAxisRaw</code>只返回-1,0,1三个值,没有过渡态, 一般用于2D游戏中</p></li><li><p>触摸</p><table><thead><tr><th>静态属性</th><th></th></tr></thead><tbody><tr><td><code>Input.touchCount</code></td><td>返回整数，代表在当前帧所有触摸点数量（只读）</td></tr><tr><td><code>Input.touches</code></td><td>返回一个 Touch[] 数组(只读)，包含了当前帧所有触摸点</td></tr><tr><td><strong>静态方法</strong></td><td></td></tr><tr><td><code>Input.GetTouch(int index)</code></td><td>返回特定Touch</td></tr><tr><td><strong>对象属性</strong></td><td></td></tr><tr><td><code>touch.position</code></td><td></td></tr><tr><td><code>touch.phase</code></td><td>包含Began, Moved, Stationary, Ended, Canceled五个阶段的属性, 用switch判断</td></tr></tbody></table></li><li><p>陀螺仪&#x2F;重力感应</p><ul><li>前提: <code>Input.gyro.enabled = true;</code></li></ul><table><thead><tr><th>默认成员属性</th><th></th></tr></thead><tbody><tr><td><code>Input.gyro.gravity</code></td><td>重力加速度向量</td></tr><tr><td><code>Input.gyro.rotateRate</code></td><td>旋转速度</td></tr><tr><td><code>Input.gyro.attitude</code></td><td>当前的旋转方向的四元数</td></tr></tbody></table></li><li><p>设备按钮</p><p><code>Input.backButtonLeavesApp</code>: 这个值为<code>true</code>时，按下返回按钮会导致应用程序退出，否则，操作系统将处理返回按钮(Android、Windows Phone或Windows平板电脑)</p></li></ol><h2 id="Light组件-光照"><a href="#Light组件-光照" class="headerlink" title="Light组件: 光照"></a>Light组件: 光照</h2><ol><li>Directional定向光: 图穷远光源, 平行光线<ul><li>Intensity强度: 光照亮度</li><li>Shadow Type: 无阴影, 有锯齿阴影, 模糊边缘阴影</li><li>Realtime Shadows: 实时阴影<ul><li>Strength: 阴影强度</li><li>Resolution: 阴影质量</li></ul></li><li>Draw Halo: 在GO处显示光晕</li><li>Flare: 炫光</li><li>Culling Mask: 光照遮罩, 剔除不需要灯光的GO(如UI)</li></ul></li><li>Spot聚光: 手电筒</li><li>Point点光源: 灯泡球体光</li><li>Area面光源(性能消耗过高, 仅支持烘焙模式)</li></ol><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><ul><li><p>Projection投影: </p><ul><li>Perspective透视: 近大远小</li><li>Orthographic正交: 完全平面, 一般用于2D</li></ul></li><li><p>Depth: 相机显示顺序, 数值大的优先显示</p></li><li><p>Clear Flags清除标志: </p><ul><li><p>SkyBox天空盒: 可以添加SkyBox组件更改天空</p></li><li><p>Solid Color</p></li><li><p>Don’t Clear</p></li><li><p>Depth Only: 仅显示有深度GO, 拍不到的空间不显示</p><blockquote><p>如果有多个相机, 将深度高的相机设置为DepthOnly, 可以显示高深相机的内容和低深相机的内容&amp;背景</p></blockquote></li></ul></li><li><p>FOV Axis: 用于设置Field of View视野的大小</p></li><li><p>Clipping Planes剪裁平面: 只有在近面和远面之间的空间才能被捕捉到</p></li><li><p>Viewpoint Rect显示矩形: 拍摄到的内容在屏幕中的位置(x,y)和宽高(w,h), 位置默认左下角(0,0), 宽高是百分比小数</p></li></ul><h2 id="音频-AudioSource组件"><a href="#音频-AudioSource组件" class="headerlink" title="音频: AudioSource组件"></a>音频: AudioSource组件</h2><ul><li>前提: 有且只有一个GO添加了AudioListener组件用以监听</li><li>需要播放声音的GO中添加AudioSource组件</li><li>音频文件一般分为两类: 音乐和音效</li><li>AudioSource组件:<ul><li>AudioClip: 引入音频资源文件</li><li>Mute: 静音</li><li>Pitch: 音调</li><li>3D Sound Settings - Volume Rolloff: 音量衰减</li></ul></li><li>对象属性和函数:<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#">AudioSource a = GetComponent&lt;AudioSource&gt;();<br><br><span class="hljs-comment">//属性:</span><br>Debug.log(a.isPlaying);<br>a.loop = <span class="hljs-literal">true</span>;<br>a.volume = <span class="hljs-number">0.5f</span>;<br><br><span class="hljs-comment">//音乐函数:</span><br>a.Play();<br>a.Pause();<br>a.UnPause();<br>a.stop();<br><br><span class="hljs-comment">//音效函数:</span><br>a.PlayOneShot(AudioClip audioclip); <span class="hljs-comment">//一个AudioSource只能播放一个音乐,但可以播放多个音效</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="视频-VideoPlayer组件"><a href="#视频-VideoPlayer组件" class="headerlink" title="视频: VideoPlayer组件"></a>视频: VideoPlayer组件</h2><ul><li>使用VideoClip作为资源文件变量</li><li>VideoPlayer组件:<ul><li>Renderer Mode渲染模式: 选择挂载体</li><li>属性和函数参考<code>AudioSource</code></li></ul></li></ul><h2 id="角色控制-CharacterController组件"><a href="#角色控制-CharacterController组件" class="headerlink" title="角色控制: CharacterController组件"></a>角色控制: <code>CharacterController</code>组件</h2><ul><li><code>SimpleMove</code>: 自带重力效果, y轴速度为0, 角色接触地面返回true</li><li><code>Move</code>: 绝对控制, 没有重力效果, 影响位移的只有<strong>xyz的速度</strong>和**<code>Rigidbody</code>的碰撞**, 返回<code>CollisionFlags</code>对象</li></ul><h2 id="重力-Rigidbody组件"><a href="#重力-Rigidbody组件" class="headerlink" title="重力: Rigidbody组件"></a>重力: <code>Rigidbody</code>组件</h2><ul><li><code>automatic tensor</code>: 自动张量, 计算张量旋转行为</li><li><code>automatic center of mass</code>: 自动重心计算</li><li><code>interpolate</code>: 物体运动插帧, 一般在物理帧率低于app帧率时使用, 默认关闭<blockquote><p>Interpolate：使用前两次物理更新计算当前帧, 会稍滞后于它应该在的位置, 适用于刚体速度变化较大的情况或有其他影响刚体运动的物理元素<br><br>Extrapolate：使用上一次物理更新并预测下一次物理更新以计算当前帧, 会稍超前于它应该在的位置。外推通常不太准确，并且可能在可见的范围内超出碰撞边界（然后在下一帧中进行修正）。外推通常只适用于精度不重要的情况，例如刚体以恒定速度移动，并且没有其他影响刚体运动的物理元素</p></blockquote><blockquote><p>启用时Unity会忽略任何不是来自物理系统的变换更改, 对<code>transform</code>进行任何直接（非物理）更改后使用Physics.SyncTransforms调用</p></blockquote></li><li><code>Collision Detection</code>: 碰撞检测频率<ul><li><code>Discrete</code>: 离散检测(默认,多数情况够用)</li><li><code>Continues</code>: 连续</li><li><code>Continues Dynamic</code>: 连续动态检测, 性能消耗最高</li><li><code>Continues Speculative</code>: 处于Continues和Discrete之间</li></ul></li><li><code>Constraints</code>: 冻结某一方面的transform</li></ul><h2 id="碰撞-Collider组件"><a href="#碰撞-Collider组件" class="headerlink" title="碰撞: Collider组件"></a>碰撞: <code>Collider</code>组件</h2><ul><li>碰撞的条件: 两者都有<code>Collider</code>组件 &amp; 至少一个GO有<code>Rigidbody</code>组件</li><li>碰撞方法:<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collision</span>)</span>&#123;<br>  <span class="hljs-comment">//collision.colider: 与之碰撞的物体的collider</span><br>  <span class="hljs-comment">//collision.gameObject: 与之碰撞的GO对象</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionStay</span>(<span class="hljs-params">Collision collision</span>)</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionExit</span>(<span class="hljs-params">Collision collision</span>)</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter</span>(<span class="hljs-params">Collider other</span>)</span>&#123;<br>  <span class="hljs-comment">//other就是触发的collider</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerStay</span>(<span class="hljs-params">Collider other</span>)</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerExit</span>(<span class="hljs-params">Collider other</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><code>Material</code>: 使用<code>Physical Material</code>文件, 创建<code>Friction</code>摩擦力<ul><li><code>Bounciness</code>: 弹力, 1没有能量损失</li><li><code>Xx Combine</code>: 两个摩擦GO时如何计算</li></ul></li></ul><h2 id="铰链关节-弹簧关节和固定关节-Hinge-Joint-Spring-Jonit和Fixed-Joint组件"><a href="#铰链关节-弹簧关节和固定关节-Hinge-Joint-Spring-Jonit和Fixed-Joint组件" class="headerlink" title="铰链关节,弹簧关节和固定关节: Hinge Joint,Spring Jonit和Fixed Joint组件"></a>铰链关节,弹簧关节和固定关节: <code>Hinge Joint</code>,<code>Spring Jonit</code>和<code>Fixed Joint</code>组件</h2><ul><li><code>Anchor</code>: 轴原点</li><li><code>Axis</code>: 轴向量</li></ul><h2 id="射线检测"><a href="#射线检测" class="headerlink" title="射线检测"></a>射线检测</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>&#123;<br>  <span class="hljs-keyword">if</span>(Input.GetMouseButtonDown(<span class="hljs-number">0</span>))&#123;<br>    <span class="hljs-comment">//从Camera发射一个射线</span><br>    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);<br>    <span class="hljs-comment">// 声明一个RaycastHit对象接受hit结果</span><br>    RaycastHit hit;<br>    <span class="hljs-comment">//使用Physics.Raycast函数发射ray, 并将发射结果保存到引用参数hit中</span><br>    <span class="hljs-keyword">if</span>(Physics.Raycast(ray,<span class="hljs-keyword">out</span> hit))&#123;<br>      <span class="hljs-comment">//打印在3Dunity中与射线相撞的第一个rigidbody的撞击坐标</span><br>      Debug.log(hit.point);<br>    &#125;<br><br>    <span class="hljs-comment">//如果检测多个rigidbody相撞目标,需要实例化RaycastHit[]数组接收, 使用Physics.RaycastAll(Ray ray)多次检测</span><br>    RaycastHit[] hit = Physics.RaycastAll(ray,[<span class="hljs-built_in">int</span> 检测距离],[<span class="hljs-built_in">int</span> 检测图层],[...]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="粒子系统-Partical-System组件"><a href="#粒子系统-Partical-System组件" class="headerlink" title="粒子系统: Partical System组件"></a>粒子系统: <code>Partical System</code>组件</h2><ul><li><code>Prewarm</code>: 从stop开始时, 是否从0逐渐展开</li><li><code>Start Lifetime</code>: 粒子在空中的存在时间</li><li><code>3D Start Size/Rotation</code>: 开启后转换为3D粒子;默认为面向Camera的平面粒子</li><li><code>Flip Rotation</code>: 水平翻转旋转</li><li><code>Gravity Modifier</code>: 粒子重力效果<ul><li><code>Constant</code>: 固定值,[-1上重力,1下重力]</li><li><code>Curve</code>: 受力曲线</li></ul></li><li><code>Simulation Space</code>: 生成的粒子是否随GO移动而移动;Local随,World不随,Custom绑定其他GO</li></ul><h2 id="线段和拖尾-LineRenderer和TrailRenderer组件"><a href="#线段和拖尾-LineRenderer和TrailRenderer组件" class="headerlink" title="线段和拖尾: LineRenderer和TrailRenderer组件"></a>线段和拖尾: <code>LineRenderer</code>和<code>TrailRenderer</code>组件</h2><h2 id="旧动画-Animation组件"><a href="#旧动画-Animation组件" class="headerlink" title="旧动画: Animation组件"></a>旧动画: <code>Animation</code>组件</h2><ul><li><code>Culling Typ</code>: 是否一直播放动画</li><li>动画窗体: ctrl+6</li><li>使用类似AudioSource: Play(),animation clip</li></ul><h2 id="新动画-Animator组件"><a href="#新动画-Animator组件" class="headerlink" title="新动画: Animator组件"></a>新动画: <code>Animator</code>组件</h2><ul><li><code>Controller</code>: 由<code>AnimatorController.controller</code>资源文件控制</li><li><code>Culling Mode</code>: <code>Cull Update Transforms</code>表示不在镜头时暂停渲染, <code>Cull Completely</code>表示不在镜头时完全停止</li><li>在Window-Animation中创建不同的动画资源<code>.anim</code>文件, 在Window-Animator中作为不同的动画状态<code>State</code>进行管理</li><li><code>.controller</code>文件包含了三方面内容: <ul><li>对<code>.anim</code>文件的引用</li><li>对<code>.anim</code>文件的设置</li><li><code>.anim</code>文件之间的相互连接关系</li></ul></li></ul><h3 id="动画的构成-anim文件"><a href="#动画的构成-anim文件" class="headerlink" title="动画的构成: anim文件"></a>动画的构成: <code>anim</code>文件</h3><ul><li><code>Rig</code> - <code>Animation Type</code>: 动画类型<ul><li>无: 不包含动画</li><li><code>Legacy</code>旧版: 只能用<code>Animation</code>旧版动画组件</li><li><code>Generic</code>泛型: 新版动画, 各种非人动画</li><li><code>Humanoid</code>人型: 新版动画, 用于人</li></ul></li><li><code>Rig</code> - <code>Avatar</code>骨骼: 从模型或从其他地方</li><li><code>Animation</code>: 对动画Clip进行细操<ul><li><code>Loop Match</code>: 首位帧是否相似</li><li><code>Bake Into Pose</code>: 烘焙特定方向的位移, 避免在动画过程中发生位移</li><li><code>Curves</code>曲线: 随动画播放时间的函数曲线, 其值同步在<code>animator</code>的同名<code>parameters</code>中</li><li><code>Events</code>事件: 在动画的某一帧调用函数(如脚步踏地时发出脚步声)</li></ul></li><li><code>Blend Tree</code> in AnimatorWindowContext: 混合动画(如走和跑的混合)<ul><li><code>Blend Type</code>混合模式: 由几个变量控制混合动画的计算, 变量在<code>animator</code>的同名<code>parameters</code>中</li><li><code>Motion</code>: 选择混合的动画</li><li><code>Automate Thresholds</code>: 是否默认各个<code>Motion</code>的取值范围</li></ul></li><li><code>Sub-State Machine</code> in AnimatorWindowContext子状态机: 不同的动画状态的分组归类<ul><li>如拿枪到一个子状态中, 换刀到另一个子状态中</li></ul></li><li><code>Base Layer</code>: 动画状态图层<ul><li><code>Weight</code>:权重; <code>Mask</code>: Avatar骨骼遮罩; <code>IK</code>: 反向动力学效果;</li><li>不使用<code>Mask</code>可以通过控制 <code>Weight</code>获得同<code>Blend Tree</code>一样的效果, 使用<code>Mask</code>可以精确实现不同部位动画的混合</li></ul></li></ul><h2 id="导航系统-需要在PackageManagement中安装AI-Navigation组件"><a href="#导航系统-需要在PackageManagement中安装AI-Navigation组件" class="headerlink" title="导航系统(需要在PackageManagement中安装AI Navigation组件)"></a>导航系统(需要在PackageManagement中安装<code>AI Navigation</code>组件)</h2><h3 id="1-静态障碍物"><a href="#1-静态障碍物" class="headerlink" title="1.静态障碍物"></a>1.静态障碍物</h3><ul><li>首先将道路GO勾选为<code>Navigation Static</code>, 然后在选择Window - AI - Navigation设置烘焙; 接着将PlayerGO添加<code>NavMeshAgent</code>组件</li><li><code>Bake</code>: 烘焙Agent的半径, 高度, 可上最大坡度Slope, 台阶每一阶步高, 可掉落的高度, 可跳跃的距离. (可以添加多个Agent, 作为高矮胖瘦不同的人)</li><li><code>掉落高度</code>和<code>跳跃距离</code>是通过生成<code>OffMeshLinks</code>实现, 需要勾选需要生成links的障碍物GO的<code>Object</code> - <code>Generate OffMeshLinks</code></li><li><code>Area</code>: 不同区域的成本消耗设置, 在<code>Object</code> - <code>Navigation Area</code>中更改</li><li><code>Nav Mesh Agent</code>组件:<ul><li><code>Steering</code>: 位移相关<ul><li><code>Acceleration</code>: 加速度</li></ul></li><li><code>Obstacle Avoidance</code> - <code>Priority</code>: 一个路口多个Agent待通过时的优先级</li><li><code>Area Mask</code>区域遮罩: 特定区域永远不可通过, 用于针对不同Agent设定不同的禁止区域</li></ul></li><li>代码实现:<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//前面获取代理组件</span><br><span class="hljs-keyword">using</span> UnityEngine.AI;<br>NavMeshAgent agent = GetComponent&lt;NavMeshAgent&gt;();<br><br><span class="hljs-comment">//在Update方法中逐帧更新:</span><br><span class="hljs-keyword">if</span>(GetMouseButtonDown(<span class="hljs-number">0</span>))&#123;<br>  Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);<br>  RaycastHit hit;<br>  <span class="hljs-keyword">if</span>(Physics.Raycast(ray, <span class="hljs-keyword">out</span> hit)) <span class="hljs-comment">//从屏幕点击到3D位置坐标</span><br>  &#123; <br>    agent.SetDestination(<span class="hljs-keyword">new</span> Vector3(hit.point)); <span class="hljs-comment">//将坐标设为destination</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-动态障碍物"><a href="#2-动态障碍物" class="headerlink" title="2.动态障碍物"></a>2.动态障碍物</h3><ul><li>将特定的某些GO取消勾选<code>Navigation Static</code>, 并添加<code>NavMeshObstacle</code>组件<ul><li><code>Carve</code>切割: 勾选后会根据该GO的位移重新烘焙原有的静态障碍道路<ul><li><code>Move Threshold</code>移动阈值: 最小移动多远时开始rebake</li><li><code>Time to Stationary</code>静止时间: 移动阈值后经过多少秒开始rebake</li><li><code>Carve Only Stationary</code>仅在静止时切割: 取消后会随着位移即时rebake, 性能消耗较大</li></ul></li></ul></li></ul><h3 id="3-点对点定点传送-Off-Mesh-Link组件"><a href="#3-点对点定点传送-Off-Mesh-Link组件" class="headerlink" title="3.点对点定点传送: Off Mesh Link组件"></a>3.点对点定点传送: <code>Off Mesh Link</code>组件</h3><ul><li><code>Auto Update Position</code>: 当GO位置改变时, 即时更新<code>Link</code>; 如果位置不会改变就取消,以降低能耗</li></ul><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul><li><code>UI</code>由<code>Canvas</code>和<code>EventSystem</code>两个GO组成, <code>Canvas</code>为所有UI控件GO的父物体</li><li><code>Canvas</code>组件:<ul><li><code>Render Mode</code>: <ul><li><code>OverLay</code>: 永远在最上层</li><li><code>Camera</code>: 可被其他GO覆盖</li><li><code>World Space</code>: 在3D世界中的一层平面, 可旋转</li></ul></li><li><code>Sort Order</code>: 多个<code>Canvas</code>时的渲染优先级</li></ul></li><li><code>Image</code>组件:<br><code>Raycast Target</code>: 是否接收射线投射<br><code>Anchors</code>: 缩放参照锚点<br><code>Pivot</code>: 图片的轴心, 图片的旋转缩放坐标都是由轴心控制</li><li>字体: 新版更清晰, 富文本更多<ul><li><code>Color Gradient</code>: 颜色渐变</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/06/hello-world/"/>
    <url>/2024/02/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
