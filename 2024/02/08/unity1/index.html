

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wanderer">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言 一定要多练习 扩展发散 学完后尝试建立自己的游戏框架  内容快捷键场景区 中键: 同Q 右键+wasd: 作为player移动 Alt+左键: 转动视角 E: 旋转Rotate R: 缩放Scale T: 矩形缩放Rect，只管一个平面矩形的缩放，一般用于2D平面，如UI Y: 全都有  Game Object Sphere平面和Quad矩形的区别 Sphere三角面更多, 可以支撑更精确复">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity1 - Gamer羽飞">
<meta property="og:url" content="http://zxk2099.github.io/2024/02/08/unity1/index.html">
<meta property="og:site_name" content="Wandering Notes">
<meta property="og:description" content="前言 一定要多练习 扩展发散 学完后尝试建立自己的游戏框架  内容快捷键场景区 中键: 同Q 右键+wasd: 作为player移动 Alt+左键: 转动视角 E: 旋转Rotate R: 缩放Scale T: 矩形缩放Rect，只管一个平面矩形的缩放，一般用于2D平面，如UI Y: 全都有  Game Object Sphere平面和Quad矩形的区别 Sphere三角面更多, 可以支撑更精确复">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-02-07T18:40:40.000Z">
<meta property="article:modified_time" content="2024-02-10T21:20:00.000Z">
<meta property="article:author" content="Wanderer">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Unity1 - Gamer羽飞 - Wandering Notes</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zxk2099.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wandering Notes</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                
                <span>时间线</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                
                <span>归类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Unity1 - Gamer羽飞"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-08 02:40" pubdate>
          2024年2月8日 凌晨02:40
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          52 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Unity1 - Gamer羽飞</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol>
<li>一定要多练习</li>
<li>扩展发散</li>
<li>学完后尝试建立自己的游戏框架</li>
</ol>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="场景区"><a href="#场景区" class="headerlink" title="场景区"></a>场景区</h3><ul>
<li>中键: 同Q</li>
<li>右键+wasd: 作为player移动</li>
<li>Alt+左键: 转动视角</li>
<li>E: 旋转Rotate</li>
<li>R: 缩放Scale</li>
<li>T: 矩形缩放Rect，只管一个平面矩形的缩放，一般用于2D平面，如UI</li>
<li>Y: 全都有</li>
</ul>
<h2 id="Game-Object"><a href="#Game-Object" class="headerlink" title="Game Object"></a>Game Object</h2><ul>
<li>Sphere平面和Quad矩形的区别<ul>
<li>Sphere三角面更多, 可以支撑更精确复杂的计算; Quad三角面只有两个</li>
<li>Sphere一般没有y, Quad一般没有z</li>
</ul>
</li>
<li>不同GO的本质区别在于不同GO的Mesh Filter组件中Mesh属性的取值不同</li>
</ul>
<h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><ul>
<li>在C#中通过Transform实例化的对象来访问对象本身的Position，Rotation变量是世界坐标系下的值。<br><code>transform.position; transform.rotation;</code></li>
<li>若想获取与组件上的本地坐标则应访问<code>transform.localPosition</code>和<code>transform.localRotation</code></li>
<li>从世界坐标转成相对父对象的局部坐标: <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">transform.TransformPoint(transform.localPosition);<br><span class="hljs-comment">//局部坐标转世界坐标</span><br>transform.parent.InverseTransformPoint(transform.position);<br><span class="hljs-comment">//世界坐标转局部坐标</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="游戏资源管理"><a href="#游戏资源管理" class="headerlink" title="游戏资源管理"></a>游戏资源管理</h2><ul>
<li>导入导出包UnityPackageFile: unity自身的一个压缩包</li>
<li>fbx: 3D模型文件</li>
<li>默认Material材质不可更改, 更改需要新建一个Material并应用到对应的GO上. 通过GO的MeshRenderer组件中Material组件可以添加各自的Material, 不同的Material通过选定的Shader着色器(默认Standard)渲染到GO上. </li>
<li>Window-&gt;Package Manager管理在Assets Store下载的资源包</li>
</ul>
<h2 id="Terrain地形"><a href="#Terrain地形" class="headerlink" title="Terrain地形"></a>Terrain地形</h2><ol>
<li>添加相邻地形</li>
</ol>
<ul>
<li>FillHeightmapUsing: 连接地形的方法<ul>
<li>clamp: 相邻瓦片交叉混合</li>
<li>mirror: 镜像</li>
</ul>
</li>
</ul>
<ol start="2">
<li>绘制地形<blockquote>
<p>Opacity: 不透明度</p>
</blockquote>
</li>
</ol>
<ul>
<li>Paint Holes: 镂空画洞</li>
<li>Set Height: 设置高度<ul>
<li>Flatten Tile: 展平当前terrain</li>
<li>Flatten All: 展平所有terrain</li>
</ul>
</li>
<li>Smooth Height: 平滑高度<ul>
<li>Blur Direction: 仅向下舍去-1,双向0,仅向上进入1</li>
</ul>
</li>
<li>Stamp Terrain: 只能点一下, 不能滑动绘制</li>
<li>Paint Texture: 绘制纹理<ul>
<li>在Terrain Layer中选择Texture资源<blockquote>
<p>Tips: 一般不用绘制, 只需要了解</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>画树</li>
</ol>
<ul>
<li>Mass Place Tree: 大量放置树</li>
</ul>
<ol start="4">
<li>绘制细节</li>
</ol>
<ul>
<li>Add Grass Texture: 给地面添加草<ul>
<li>最终强度: 草的密集程度</li>
</ul>
</li>
</ul>
<ol start="5">
<li>地形设置</li>
</ol>
<h2 id="脚本的生命周期"><a href="#脚本的生命周期" class="headerlink" title="脚本的生命周期"></a>脚本的生命周期</h2><p>![Unity官方图解](D:\Program Files\Typora\assets\unity1\f366aa7d27e1514bb579b495f09942bf.png)</p>
<ol>
<li><p>Awake：初始化时调用，通常使用为需要提前初始化的逻辑。比如单例赋值<code>private void Awake()&#123;Instance = this;&#125;</code></p>
</li>
<li><p>OnEnable：在对象启用时调用，处理每次显示时都需要进行初始化的逻辑，通常和OnDisable配合使用。<br>比如: 游戏逻辑使用并修改了变量<code>Number</code>，而下次显示时使用是又需要<code>Number = 1</code>，此时就可以写<code>private void Awake()&#123;Number = 1;&#125;</code></p>
</li>
<li><p>Start：仅当启用脚本实例时，才会在第一帧调用。通常使用为一些变量初始化逻辑。比如：获取指定物体：<code>private void Start()&#123;child1 = transform.GetChild(0);&#125;</code></p>
</li>
<li><p>Fixed Update：固定时间调用，所有物理计算和更新都在Fixed Update中处理，不受帧率影响。比如：一些物理属性的更新操作Force，Collider，Rigidbody等。</p>
</li>
<li><p>Update：每帧调用一次，根据帧率的快慢影响执行速度。通常的游戏逻辑都写在这里，比如：和玩家交换，当用户按下空格时进行执行什么操作。</p>
</li>
<li><p>LateUpdate：在Update完成后，每帧调用一次。常见用处是相机跟随主角，比如：主角在Update中移动，则可以在LateUpdate执行相机的移动，这将可以保证摄像机跟着的时候之前的逻辑一起完全执行完成。</p>
</li>
<li><p>OnMouseXXX: 通过鼠标的射线检测来判断鼠标当前位置是否碰到了挂载脚本游戏对象的碰撞体。</p>
<ul>
<li><p>前提：</p>
<ul>
<li>只能检测当前脚本挂载的游戏对象。</li>
<li>当前游戏对象需要有碰撞体。</li>
<li>不能有其他物体(UI)遮挡到此游戏对象。</li>
</ul>
</li>
<li><p>函数：</p>
<ul>
<li>OnMouseEnter: 鼠标进入时调用一次</li>
<li>OnMouseOver: 鼠标停留(经过)时一直调用</li>
<li>OnMouseExit: 鼠标退出时调用一次</li>
<li>OnMouseDown: 鼠标按下时调用一次</li>
<li>OnMouseDrag: 鼠标拖拽(按住)时一直调用</li>
<li>OnMouseUp: 鼠标抬起时调用一次</li>
</ul>
</li>
<li><p>应用（一般成对使用）：</p>
<ul>
<li>OnMouseEnter，OnMouseOver，OnMouseExit 一组。比如模拟选中状态：鼠标进入时物体变色，鼠标退出时再变回来。</li>
<li>OnMouseDown，OnMouseDrag，OnMouseUp 一组。比如射击游戏：鼠标按下拖拽时调整方向，抬起时发射子弹。</li>
<li>当鼠标按下并停留在当前游戏对象上时，OnMouseOver，OnMouseDrag会同时触发。</li>
</ul>
</li>
</ul>
</li>
<li><p>OnTriggerXX:</p>
<ul>
<li><p>函数</p>
<ul>
<li>OnCollisionEnter: 进入碰撞时触发一次。</li>
<li>OnCollisionStay: 在碰撞体中停留时每帧触发一次。</li>
<li>OnCollisionExit: 离开碰撞体时触发一次。</li>
<li>OnTriggerEnter: 进入碰撞体时触发一次。</li>
<li>OnTriggerStay: 在碰撞体中停留时每帧触发一次。</li>
<li>OnTriggerExit: 离开碰撞体是触发一次。</li>
</ul>
<blockquote>
<p>还有对应2D碰撞体的六个方法（如：<code>OnCollisionEnter2D</code>） 函数后面添加2D接口，触发条件和使用方式和3D一致。 使用时注意碰撞体和检测函数同步接口，即用2D碰撞体必须用2D函数。</p>
</blockquote>
</li>
<li><p>前提同上</p>
</li>
</ul>
</li>
<li><p>OnApplicationXX:</p>
<ul>
<li>函数:<ul>
<li>OnApplicationPause: 检测到暂停的帧结束 –&gt; 切换到后台和回来时调用。游戏停止保存数据&#x2F;游戏继续数据初始化。</li>
<li>OnApplicationFocus: 当屏幕 获得&#x2F;失去 焦点时调用。失去焦点关闭背景音乐&#x2F;获得焦点继续播放音乐。</li>
<li>OnApplicationQuit: 当程序退出时调用。在移动端大退时也会对调用，但不会触发上面两个方法。</li>
</ul>
</li>
</ul>
</li>
<li><p>禁用与销毁</p>
<ul>
<li><code>OnDisable</code>: 当对象被禁用时调用此函数（其父物体被禁用也会触发）。通常和OnEnable配合使用。比如：在OnEnable添加监听，在OnDisable移除监听</li>
<li><code>OnDestroy</code>: 在对象存在的最后一帧的所有帧更新之后调用此函数。当物体销毁或者场景关闭时触发。比如：子弹打到墙壁时，需要销毁子弹并触发一个打击音效。</li>
</ul>
</li>
</ol>
<h2 id="脚本执行顺序"><a href="#脚本执行顺序" class="headerlink" title="脚本执行顺序"></a>脚本执行顺序</h2><ul>
<li><p>先执行所有的<code>Awake()</code>, 再执行所有的<code>Start()</code></p>
</li>
<li><p>Execution Order中设置cs脚本执行顺序, 数值越小越先执行</p>
</li>
</ul>
<h2 id="标签和图层"><a href="#标签和图层" class="headerlink" title="标签和图层"></a>标签和图层</h2><ul>
<li>给GO分组的工具</li>
<li>图层可以在Camera组件Culling Mask属性中选择遮罩图层, 实现显隐不同图层的功能</li>
</ul>
<h2 id="Prefab预制体与变体"><a href="#Prefab预制体与变体" class="headerlink" title="Prefab预制体与变体"></a>Prefab预制体与变体</h2><ul>
<li><p>以.prefab文件存储的GO, 可以通过GO快速创建别人打包好的GO</p>
</li>
<li><p>在Scene中的GO组件发生改变, 可以通过右键组件应用到Prefab文件的修改</p>
</li>
<li><p>通过预制体创建的GO发生大改变, 将GO独立为新的prefab时, 选择<code>原始预制体</code>将保留对原始预制体的引用, 选择<code>预制体变体</code>将不再保留对原始预制体的引用</p>
</li>
<li><p>通过代码来创建GO就可以考虑使用预制体</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> GameObject sphere; <span class="hljs-comment">//首先public一个GO变量, 然后在unity面板中拖入特定的预制体</span><br>Instantiate(sphere,transform); <span class="hljs-comment">//使用Instantiate初始化这个变量, 并将其设置为当前GO的子GO.该函数返回值为go对象</span><br>Destroy(Instantiate(sphere,transform)); <span class="hljs-comment">//创建并销毁go</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Vector3"><a href="#Vector3" class="headerlink" title="Vector3"></a>Vector3</h2><ul>
<li><p>常用常量</p>
<ul>
<li><p><code>Vector3.zero</code>: (0,0,0)</p>
</li>
<li><p><code>Vector3.one</code>: (1,1,1)</p>
</li>
</ul>
</li>
<li><p>函数</p>
<ul>
<li><p><code>Vector3.Angle(new Vector3(0,0,0),new Vector3(1,1,1))</code>: 两个向量之间的夹角</p>
</li>
<li><p><code>Vector3.Distance(new Vector3(0,0,0),new Vector3(1,1,1))</code>: 两个坐标之间的距离</p>
</li>
<li><p><code>Vector3.Dot(new Vector3(0,0,0),new Vector3(1,1,1))</code>: 两个向量的乘积(返回&#x3D;&#x3D;标量&#x3D;&#x3D;)</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//Dot源码</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">float</span> <span class="hljs-title">Dot</span>(<span class="hljs-params">Vector3 lhs, Vector3 rhs</span>)</span><br>&#123;<br> <span class="hljs-keyword">return</span> lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>a</strong>⋅<strong>b</strong>&#x3D;(x<del>1</del>,y<del>1</del>,z<del>1</del>)⋅(x2,y2,z2)&#x3D;x1×x2+y1×y2+z1×z2&#x3D;|<strong>a</strong>|×|<strong>b</strong>|×<em>cos</em>θ</p>
<p>通过<strong>取值正负</strong>可以判断两向量<strong>方向是否相同</strong>; 通过<strong>取值是否为0</strong>可以判断<strong>是否垂直</strong></p>
</blockquote>
</li>
<li><p><code>Vector3.Cross(new Vector3(0,0,0),new Vector3(1,1,1))</code>: 两个向量的叉乘(返回&#x3D;&#x3D;Vector3对象&#x3D;&#x3D;)</p>
<blockquote>
<p>&#x2F;&#x2F;Cross源码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector3 <span class="hljs-title">Cross</span>(<span class="hljs-params">Vector3 lhs, Vector3 rhs</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>a</strong>×<strong>b</strong>&#x3D;(a1,a2,a3)×(b1,b2,b3)&#x3D;(a2×b3−a3×b3,a3×b1−a1×b3,a1×b2−a2×b1))</p>
<p>|<strong>a</strong>×<strong>b</strong>|&#x3D;|<strong>a</strong>|×|<strong>b</strong>|×sinβ</p>
<p>叉乘的几何意义表示为求得以<strong>a</strong>和<strong>b</strong>为平面的法线向量<strong>c</strong>, <strong>c</strong>⊥<strong>a</strong>与<strong>b</strong>组成的平面, <strong>c</strong>的模|<strong>c</strong>|&#x3D;|<strong>a</strong>|×|<strong>b</strong>|×sinβ, 或以<strong>a</strong>和<strong>b</strong>组成的平行四边形的面积</p>
<p>若两者叉乘之模为0, 则<strong>a</strong>与<strong>b</strong>相互平行; 若两者叉乘之模等于两者各自的模的乘积, 则<strong>a</strong>与<strong>b</strong>相互垂直</p>
</blockquote>
</li>
<li><p><code>Vector3.Lerp(new Vector3(0,0,0),new Vector3(1,1,1),0.5f)</code>: 两个Vector3之间插值</p>
</li>
</ul>
</li>
<li><p>对象常量(<code>Vector3 v = new Vector3(1,1,1);</code>)</p>
<ul>
<li><code>v.magnitude</code>: Vector3的模</li>
</ul>
</li>
</ul>
<h2 id="Euler欧拉角与Quaternion四元数"><a href="#Euler欧拉角与Quaternion四元数" class="headerlink" title="Euler欧拉角与Quaternion四元数"></a>Euler欧拉角与Quaternion四元数</h2><ul>
<li><p>Euler的实例化: 同Vector3</p>
<p><code>Vector3 rotate = new Vector3(0,30,0);</code></p>
</li>
<li><p>Quaternion的实例化: </p>
<ul>
<li>常量(0,0,0,0): <code>Quaternion.identity</code></li>
<li>欧拉角to四元数: <code>Quaternion quaternion = Quaternion.Euler(new Vector3(0,30,0));</code></li>
<li>四元数to欧拉角: <code>Vector3 vector3 = quaternion.eulerAngles;</code></li>
</ul>
</li>
</ul>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><ul>
<li>输出文本Text: <ul>
<li>调试输出: <code>Debug.log(&quot;Text&quot;);</code></li>
<li>调试输出警告: <code>Debug.logWarning(&quot;Text&quot;);</code></li>
<li>调试输出错误: <code>Debug.logError(&quot;Text&quot;);</code></li>
</ul>
</li>
<li>画线<ul>
<li>画直线: <code>Debug.DrawLine(Vector3.zero,Vector3.one,[Color.Green]); //两个必需参数为两个点坐标</code></li>
<li>画射线: <code>Debug.DrawRay(Vector3.zero,Vector3.one,[Color.Green]); //第一个参数是起始点坐标, 第二个参数为射线向量</code></li>
</ul>
</li>
</ul>
<h2 id="组件属性的修改"><a href="#组件属性的修改" class="headerlink" title="组件属性的修改"></a>组件属性的修改</h2><ul>
<li><p>获取GO和transform: </p>
<ul>
<li><p>获取本GO: <code>GameObject go = this.gameObject;</code> 也可直接使用<code>gameObject</code>代替<code>this.gameObject</code> </p>
<blockquote>
<p>GO的父子关系控制在<code>transform</code>组件中, 上面的<code>this</code>表示的是本<code>GO</code>的<code>transform</code>, 所以上面的<code>this.gameObject</code>也可以写为<code>transform.gameObject</code></p>
</blockquote>
</li>
<li><p>获取其他无关GO: </p>
<ul>
<li><p><code>public GameObject go;</code> 然后通过unity面板选择</p>
</li>
<li><p><code>GameObject.Find(&quot;name&quot;)</code>; 使用<code>GameObject</code>类方法根据name寻找</p>
</li>
<li><p><code>GameObject.FindWithTag(&quot;tag&quot;)</code>; 使用<code>GameObject</code>类方法根据tag寻找</p>
</li>
</ul>
</li>
<li><p>获取父物体GO:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">Transform parent = transform.parent; <span class="hljs-comment">// 获取物体的直接父物体</span><br>Transform root = transform.root; <span class="hljs-comment">// 获取物体的根物体</span><br><span class="hljs-built_in">int</span> hierarchy = transform.GetSiblingIndex(); <span class="hljs-comment">// 获取物体在父物体中的层级索引.根物体的层级索引为0，其直接子物体的层级索引依次递增</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>获取子物体GO: </p>
<ul>
<li>获取所有层级所有子物体, 包括本物体: <code>GetComponentsInChildren()</code></li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">Transform[] myTransforms = GetComponentsInChildren&lt;Transform&gt;();<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> child <span class="hljs-keyword">in</span> myTransforms)&#123;Debug.Log(child.name);&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>通过name获取<strong>一级</strong>子物体: <code>transform.Find(&quot;Child0&quot;)</code></p>
<blockquote>
<p>获取<strong>二级</strong>子物体需要<strong>全路径</strong>: <code>transform.Find(&quot;Child0/Child00&quot;)</code></p>
<p>&#x3D;&#x3D;注意: 对象<code>gameObject</code>没有此方法, <code>transform</code>有此方法, <code>transform</code>对象的方法只能寻找本身及子物体, <code>GameObject</code>类方法是从所有层级所有物体中寻找&#x3D;&#x3D;</p>
</blockquote>
</li>
<li><p>通过index获取一级子物体: <code>transform.GetChild(1)</code></p>
<blockquote>
<p>获取<strong>二级</strong>子物体需要<strong>连续两次调用</strong>: <code>transform.GetChild(1).GetChild(0)</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>GameObject</code>类的实例化需要到unity面板中选择, 在代码中的<code>gameObject</code>是<code>transform</code>对象的一个属性, 获得的所有父子GO物体均为相应的<code>transform</code>对象</p>
</li>
</ul>
</li>
<li><p>GO&#x2F;transform的属性和函数: </p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#">go.name<br>go.tag<br>go.layer<br>go.activeInHierarchy <span class="hljs-comment">//是否激活状态在层级中</span><br>go.activeSelf <span class="hljs-comment">//本身是否激活状态</span><br><span class="hljs-comment">//两个同时为真才是激活状态, 只要有一个为假就不是激活状态</span><br>go.AddComponent&lt;BoxCollider&gt;(); <span class="hljs-comment">//添加组件</span><br>go.SetActive(<span class="hljs-literal">true</span>); <span class="hljs-comment">//设置是否激活, 这是go的函数, transform无法管控GO是否激活</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>获取其他组件: <code>BoxCollider bc = GetComponent&lt;BoxCollider&gt;();</code>或直接使用匿名函数接想用的属性<code>GetComponent&lt;BoxCollider&gt;().xxx</code></p>
</li>
<li><p>获取父物体的特定组件: <code>GetComponentInParent&lt;BoxCollider&gt;()</code></p>
</li>
<li><p>获取子物体的特定组件: <code>BoxCollider[] bc = GetComponentInChidren&lt;BoxCollider&gt;()</code>, 会遍历包含本身在内的所有层级所有子物体</p>
</li>
</ul>
<h2 id="Time类"><a href="#Time类" class="headerlink" title="Time类"></a>Time类</h2><ol>
<li><p>Time类属性</p>
<table>
<thead>
<tr>
<th>总时间</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>Time.time</code></td>
<td>帧时间</td>
</tr>
<tr>
<td><code>Time.unscaledTime</code></td>
<td>不受Scale约束的帧时间</td>
</tr>
<tr>
<td><code>Time.fixedTime</code></td>
<td>频率时间&#x2F;不受帧约束的时间</td>
</tr>
<tr>
<td><code>Time.unscaledFixedTime</code></td>
<td>不受Scale约束的频率时间</td>
</tr>
<tr>
<td><code>Time.realtimeSinceStartup</code></td>
<td>不受Scale影响的实际时间</td>
</tr>
<tr>
<td><code>Time.timeSinceLevelLoad</code></td>
<td>自最后一个非添加场景（non-additive scene）完成加载以来的Scaled时间</td>
</tr>
<tr>
<td><strong>增量时间</strong></td>
<td></td>
</tr>
<tr>
<td><code>Time.deltaTime</code></td>
<td>帧间隔时间&#x2F;Δ帧时间</td>
</tr>
<tr>
<td><code>Time.unscaledDeltaTime</code></td>
<td>不受Scale约束的帧间隔时间</td>
</tr>
<tr>
<td><code>Time.fixedDeltaTime</code></td>
<td>频率间隔时间&#x2F;不受帧约束的时间间隔</td>
</tr>
<tr>
<td><code>Time.fixedUnscaledDeltaTime</code></td>
<td>不受Scale约束的频率间隔时间</td>
</tr>
<tr>
<td><strong>其他</strong></td>
<td></td>
</tr>
<tr>
<td><code>Time.frameCount</code></td>
<td>总帧数</td>
</tr>
<tr>
<td><code>Time.timeScale</code></td>
<td>时间缩放尺度, 默认为1, 为0停止, 为2二倍速</td>
</tr>
<tr>
<td><code>Time.maximumDeltaTime</code></td>
<td>最大帧增量时间</td>
</tr>
<tr>
<td><code>Time.maximumParticleDeltaTime</code></td>
<td>粒子更新的最大帧增量时间</td>
</tr>
</tbody></table>
<ul>
<li>过于卡顿时, <code>Time.deltaTime</code>会增大, 但不会无限增大, 受<code>Time.maximumDeltaTime</code>限制, 而<code>Time.unscaledDeltaTime</code>不受此限制, 因此<code>Time.time</code>会比<code>Time.unscaledTime</code>慢一些.</li>
</ul>
</li>
</ol>
<h2 id="Application类"><a href="#Application类" class="headerlink" title="Application类"></a>Application类</h2><table>
<thead>
<tr>
<th>静态变量</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>Application.persistentDataPath</code></td>
<td>不同平台持久化的Assets文件夹(读写)</td>
</tr>
<tr>
<td><code>Application.streamingAssetsPath</code></td>
<td>游戏安装目录Assets目录中<code>streamingAssets</code>文件夹, 无加密(只读)</td>
</tr>
<tr>
<td><code>Application.temporaryCachePath</code></td>
<td>临时文件夹</td>
</tr>
<tr>
<td><code>Application.runInBackground</code></td>
<td>是否在后台运行</td>
</tr>
<tr>
<td><code>Application.platform</code></td>
<td>返回游戏运行平台(只读)</td>
</tr>
<tr>
<td><code>Application.systemLanguage</code></td>
<td>返回系统语言(只读)</td>
</tr>
<tr>
<td><code>Application.unityVersion</code></td>
<td>返回unity版本</td>
</tr>
<tr>
<td><strong>静态函数</strong></td>
<td></td>
</tr>
<tr>
<td><code>Application.OpenURL(&quot;http&quot;)</code></td>
<td>打开URL</td>
</tr>
<tr>
<td><code>Application.Quit</code></td>
<td>退出游戏</td>
</tr>
</tbody></table>
<h2 id="Scene类与SceneManagement类"><a href="#Scene类与SceneManagement类" class="headerlink" title="Scene类与SceneManagement类"></a><code>Scene</code>类与<code>SceneManagement</code>类</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> UnityEngine.SceneManagement <span class="hljs-comment">//引入namespace使用SceneManager类</span><br>SceneManager.LoadScene(<span class="hljs-number">1</span>); <span class="hljs-comment">//在File-BildSettings中引入不同scene获得index, 通过index加载scene</span><br>SceneManager.LoadScene(<span class="hljs-string">&quot;MyScene&quot;</span>,[defalt:LoadSceneMode.Single]LoadSceneMode.Addictive); <span class="hljs-comment">//通过name加载scene</span><br>SceneManager.UnloadSceneAsync(s); <span class="hljs-comment">//卸载scene</span><br><br>Debug.log(SceneManager.sceneCount); <span class="hljs-comment">//数量</span><br><br>Scene s = SceneManager.GetActiveScene(); <span class="hljs-comment">//当前活动scene</span><br>Scene s = SceneManager.CreateScene(<span class="hljs-string">&quot;MyScene&quot;</span>); <span class="hljs-comment">//创建scene</span><br><br>Debug.log(s.name); <span class="hljs-comment">//名字</span><br>Debug.log(s.isLoaded); <span class="hljs-comment">//是否已加载</span><br>Debug.log(s.path); <span class="hljs-comment">//文件路径</span><br>Debug.log(s.buildIndex); <span class="hljs-comment">//获取index</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//异步加载场景需要用IEnumerator协程:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTest</span>:<span class="hljs-title">Monobehavior</span><br>&#123;<br>    AsyncOperation o; <span class="hljs-comment">//实例化一个AsyncOperation对象用以记录加载过程信息</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        StartCoroutine(loading()); <span class="hljs-comment">//使用StartCoroutin()启动协程, 参数为协程函数名</span><br>    &#125;<br>    <br>    <span class="hljs-function">IEnumerator <span class="hljs-title">loading</span>() <span class="hljs-comment">//定义协程事件</span></span><br>    &#123;<br>        o = SceneManager.LoadSceneAsync(<span class="hljs-string">&quot;MyScene&quot;</span>/<span class="hljs-number">1</span>); <span class="hljs-comment">//在协程中使用异步加载场景函数, 函数返回值为AsyncOperation类对象</span><br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> o; <span class="hljs-comment">//将加载过程的信息写入o中</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        Debug.log(o.progress); <span class="hljs-comment">//0-0.9</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Transform类"><a href="#Transform类" class="headerlink" title="Transform类"></a>Transform类</h2><table>
<thead>
<tr>
<th>实例变量</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>transform.position</code></td>
<td>世界位置</td>
</tr>
<tr>
<td><code>transform.localPosition</code></td>
<td>相对位置</td>
</tr>
<tr>
<td><code>transform.rotation</code></td>
<td>世界旋转四元数</td>
</tr>
<tr>
<td><code>transform.localRotation</code></td>
<td>相对旋转四元数</td>
</tr>
<tr>
<td><code>transform.eulerAngles</code></td>
<td>世界旋转欧拉角</td>
</tr>
<tr>
<td><code>transform.localEulerAngles</code></td>
<td>相对旋转欧拉角</td>
</tr>
<tr>
<td><code>transform.localScale</code></td>
<td>缩放</td>
</tr>
<tr>
<td><code>transform.forward</code></td>
<td>GO的前后左右上下</td>
</tr>
<tr>
<td><strong>实例函数</strong></td>
<td></td>
</tr>
<tr>
<td><code>transform.LookAt(Vector3.zero)</code></td>
<td>一直看向某一个点(点坐标)</td>
</tr>
<tr>
<td><code>transform.Rotate(Vector3.up)</code></td>
<td>旋转(方向向量)</td>
</tr>
<tr>
<td><code>transform.Translate(Vector3.forward * 50 * Time.deltaTime)</code></td>
<td>向(0,0,1)移动(方向向量)</td>
</tr>
</tbody></table>
<h2 id="Input类"><a href="#Input类" class="headerlink" title="Input类"></a>Input类</h2><ol>
<li><p>按键Key</p>
<table>
<thead>
<tr>
<th>静态属性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>Input.anyKey</code></td>
<td>如果用户按下任何键(包含任意设备任意输入)，在按住不放的过程中一直返回true（只读）</td>
</tr>
<tr>
<td><code>Input.anyKeyDown</code></td>
<td>按下任何键(包含任意设备任意输入),按下的那一帧返回true(只读),之后的帧即使仍然被按住也返回false</td>
</tr>
<tr>
<td><code>Input.inputString</code></td>
<td>按下的键的值(配合<code>anyKey</code>实现自定义按键)</td>
</tr>
<tr>
<td><strong>静态方法</strong></td>
<td></td>
</tr>
<tr>
<td><code>Input.GetKey(KeyCode)</code></td>
<td>检测是否按下了任何指定键,一直按住则一直返回 true</td>
</tr>
<tr>
<td><code>Input.GetKeyDown(KeyCode)</code></td>
<td>检测是否按下了任何指定键,只有那一帧时true</td>
</tr>
<tr>
<td><code>Input.GetKeyUp(KeyCode)</code></td>
<td>释放的那一帧返回true</td>
</tr>
</tbody></table>
</li>
<li><p>按钮Button</p>
<table>
<thead>
<tr>
<th><strong>静态方法</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>Input.GetButton(string buttonName)</code></td>
<td>检测是否按下了任何按钮,一直按住则一直返回 true</td>
</tr>
<tr>
<td><code>Input.GetButtonDown()</code></td>
<td>检测是否按下了任何button,只有那一帧时true</td>
</tr>
<tr>
<td><code>Input.GetButtonUp()</code></td>
<td>释放的那一帧返回true</td>
</tr>
</tbody></table>
</li>
<li><p>鼠标</p>
<table>
<thead>
<tr>
<th>静态属性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>Input.mousePresent</code></td>
<td>是否有mouse设备连接（只读）</td>
</tr>
<tr>
<td><code>Input.mousePosition</code></td>
<td>当前鼠标位置(只读), z&#x3D;0, 左下角是(0,0,0), 右上角是分辨率</td>
</tr>
<tr>
<td><code>Input.mouseScrollDelta</code></td>
<td>鼠标滚轮滚动量(只读), 返回<code>Vector2</code>, y逆时针(0,1), 顺时针(0,-1)</td>
</tr>
<tr>
<td><strong>静态方法</strong></td>
<td></td>
</tr>
<tr>
<td><code>Input.GetMouseButton(int button)</code></td>
<td>检测是否按下了按钮,一直按住则一直返回 true, 0左键 1右键 2中键</td>
</tr>
<tr>
<td><code>Input.GetMouseButtonDown()</code></td>
<td>检测是否按下,只有那一帧时true</td>
</tr>
<tr>
<td><code>Input.GetMouseButtonUp()</code></td>
<td>释放的那一帧返回true</td>
</tr>
</tbody></table>
</li>
<li><p>虚拟轴</p>
<ul>
<li>设置内容在<code>编辑-ProjectSettings</code>中</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">float</span> h = Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>); <span class="hljs-comment">//获取水平轴(-1,1)</span><br><span class="hljs-built_in">float</span> v = Input.GetAxis(<span class="hljs-string">&quot;Vertical&quot;</span>);<br><span class="hljs-built_in">float</span> x = Input.GetAxis(<span class="hljs-string">&quot;Mouse X&quot;</span>); <span class="hljs-comment">//获取鼠标横向从移动, 左-1</span><br></code></pre></td></tr></table></figure>

<p><code>Input.GetAxisRaw</code>只返回-1,0,1三个值,没有过渡态, 一般用于2D游戏中</p>
</li>
<li><p>触摸</p>
<table>
<thead>
<tr>
<th>静态属性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>Input.touchCount</code></td>
<td>返回整数，代表在当前帧所有触摸点数量（只读）</td>
</tr>
<tr>
<td><code>Input.touches</code></td>
<td>返回一个 Touch[] 数组(只读)，包含了当前帧所有触摸点</td>
</tr>
<tr>
<td><strong>静态方法</strong></td>
<td></td>
</tr>
<tr>
<td><code>Input.GetTouch(int index)</code></td>
<td>返回特定Touch</td>
</tr>
<tr>
<td><strong>对象属性</strong></td>
<td></td>
</tr>
<tr>
<td><code>touch.position</code></td>
<td></td>
</tr>
<tr>
<td><code>touch.phase</code></td>
<td>包含Began, Moved, Stationary, Ended, Canceled五个阶段的属性, 用switch判断</td>
</tr>
</tbody></table>
</li>
<li><p>陀螺仪&#x2F;重力感应</p>
<ul>
<li>前提: <code>Input.gyro.enabled = true;</code></li>
</ul>
<table>
<thead>
<tr>
<th>默认成员属性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>Input.gyro.gravity</code></td>
<td>重力加速度向量</td>
</tr>
<tr>
<td><code>Input.gyro.rotateRate</code></td>
<td>旋转速度</td>
</tr>
<tr>
<td><code>Input.gyro.attitude</code></td>
<td>当前的旋转方向的四元数</td>
</tr>
</tbody></table>
</li>
<li><p>设备按钮</p>
<p><code>Input.backButtonLeavesApp</code>: 这个值为<code>true</code>时，按下返回按钮会导致应用程序退出，否则，操作系统将处理返回按钮(Android、Windows Phone或Windows平板电脑)</p>
</li>
</ol>
<h2 id="Light组件-光照"><a href="#Light组件-光照" class="headerlink" title="Light组件: 光照"></a>Light组件: 光照</h2><ol>
<li>Directional定向光: 图穷远光源, 平行光线<ul>
<li>Intensity强度: 光照亮度</li>
<li>Shadow Type: 无阴影, 有锯齿阴影, 模糊边缘阴影</li>
<li>Realtime Shadows: 实时阴影<ul>
<li>Strength: 阴影强度</li>
<li>Resolution: 阴影质量</li>
</ul>
</li>
<li>Draw Halo: 在GO处显示光晕</li>
<li>Flare: 炫光</li>
<li>Culling Mask: 光照遮罩, 剔除不需要灯光的GO(如UI)</li>
</ul>
</li>
<li>Spot聚光: 手电筒</li>
<li>Point点光源: 灯泡球体光</li>
<li>Area面光源(性能消耗过高, 仅支持烘焙模式)</li>
</ol>
<h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><ul>
<li><p>Projection投影: </p>
<ul>
<li>Perspective透视: 近大远小</li>
<li>Orthographic正交: 完全平面, 一般用于2D</li>
</ul>
</li>
<li><p>Depth: 相机显示顺序, 数值大的优先显示</p>
</li>
<li><p>Clear Flags清除标志: </p>
<ul>
<li><p>SkyBox天空盒: 可以添加SkyBox组件更改天空</p>
</li>
<li><p>Solid Color</p>
</li>
<li><p>Don’t Clear</p>
</li>
<li><p>Depth Only: 仅显示有深度GO, 拍不到的空间不显示</p>
<blockquote>
<p>如果有多个相机, 将深度高的相机设置为DepthOnly, 可以显示高深相机的内容和低深相机的内容&amp;背景</p>
</blockquote>
</li>
</ul>
</li>
<li><p>FOV Axis: 用于设置Field of View视野的大小</p>
</li>
<li><p>Clipping Planes剪裁平面: 只有在近面和远面之间的空间才能被捕捉到</p>
</li>
<li><p>Viewpoint Rect显示矩形: 拍摄到的内容在屏幕中的位置(x,y)和宽高(w,h), 位置默认左下角(0,0), 宽高是百分比小数</p>
</li>
</ul>
<h2 id="音频-AudioSource组件"><a href="#音频-AudioSource组件" class="headerlink" title="音频: AudioSource组件"></a>音频: AudioSource组件</h2><ul>
<li>前提: 有且只有一个GO添加了AudioListener组件用以监听</li>
<li>需要播放声音的GO中添加AudioSource组件</li>
<li>音频文件一般分为两类: 音乐和音效</li>
<li>AudioSource组件:<ul>
<li>AudioClip: 引入音频资源文件</li>
<li>Mute: 静音</li>
<li>Pitch: 音调</li>
<li>3D Sound Settings - Volume Rolloff: 音量衰减</li>
</ul>
</li>
<li>对象属性和函数:<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#">AudioSource a = GetComponent&lt;AudioSource&gt;();<br><br><span class="hljs-comment">//属性:</span><br>Debug.log(a.isPlaying);<br>a.loop = <span class="hljs-literal">true</span>;<br>a.volume = <span class="hljs-number">0.5f</span>;<br><br><span class="hljs-comment">//音乐函数:</span><br>a.Play();<br>a.Pause();<br>a.UnPause();<br>a.stop();<br><br><span class="hljs-comment">//音效函数:</span><br>a.PlayOneShot(AudioClip audioclip); <span class="hljs-comment">//一个AudioSource只能播放一个音乐,但可以播放多个音效</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="视频-VideoPlayer组件"><a href="#视频-VideoPlayer组件" class="headerlink" title="视频: VideoPlayer组件"></a>视频: VideoPlayer组件</h2><ul>
<li>使用VideoClip作为资源文件变量</li>
<li>VideoPlayer组件:<ul>
<li>Renderer Mode渲染模式: 选择挂载体</li>
<li>属性和函数参考<code>AudioSource</code></li>
</ul>
</li>
</ul>
<h2 id="角色控制-CharacterController组件"><a href="#角色控制-CharacterController组件" class="headerlink" title="角色控制: CharacterController组件"></a>角色控制: <code>CharacterController</code>组件</h2><ul>
<li><code>SimpleMove</code>: 自带重力效果, y轴速度为0, 角色接触地面返回true</li>
<li><code>Move</code>: 绝对控制, 没有重力效果, 影响位移的只有<strong>xyz的速度</strong>和**<code>Rigidbody</code>的碰撞**, 返回<code>CollisionFlags</code>对象</li>
</ul>
<h2 id="重力-Rigidbody组件"><a href="#重力-Rigidbody组件" class="headerlink" title="重力: Rigidbody组件"></a>重力: <code>Rigidbody</code>组件</h2><ul>
<li><code>automatic tensor</code>: 自动张量, 计算张量旋转行为</li>
<li><code>automatic center of mass</code>: 自动重心计算</li>
<li><code>interpolate</code>: 物体运动插帧, 一般在物理帧率低于app帧率时使用, 默认关闭<blockquote>
<p>Interpolate：使用前两次物理更新计算当前帧, 会稍滞后于它应该在的位置, 适用于刚体速度变化较大的情况或有其他影响刚体运动的物理元素<br><br>Extrapolate：使用上一次物理更新并预测下一次物理更新以计算当前帧, 会稍超前于它应该在的位置。外推通常不太准确，并且可能在可见的范围内超出碰撞边界（然后在下一帧中进行修正）。外推通常只适用于精度不重要的情况，例如刚体以恒定速度移动，并且没有其他影响刚体运动的物理元素</p>
</blockquote>
<blockquote>
<p>启用时Unity会忽略任何不是来自物理系统的变换更改, 对<code>transform</code>进行任何直接（非物理）更改后使用Physics.SyncTransforms调用</p>
</blockquote>
</li>
<li><code>Collision Detection</code>: 碰撞检测频率<ul>
<li><code>Discrete</code>: 离散检测(默认,多数情况够用)</li>
<li><code>Continues</code>: 连续</li>
<li><code>Continues Dynamic</code>: 连续动态检测, 性能消耗最高</li>
<li><code>Continues Speculative</code>: 处于Continues和Discrete之间</li>
</ul>
</li>
<li><code>Constraints</code>: 冻结某一方面的transform</li>
</ul>
<h2 id="碰撞-Collider组件"><a href="#碰撞-Collider组件" class="headerlink" title="碰撞: Collider组件"></a>碰撞: <code>Collider</code>组件</h2><ul>
<li>碰撞的条件: 两者都有<code>Collider</code>组件 &amp; 至少一个GO有<code>Rigidbody</code>组件</li>
<li>碰撞方法:<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collision</span>)</span>&#123;<br>  <span class="hljs-comment">//collision.colider: 与之碰撞的物体的collider</span><br>  <span class="hljs-comment">//collision.gameObject: 与之碰撞的GO对象</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionStay</span>(<span class="hljs-params">Collision collision</span>)</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionExit</span>(<span class="hljs-params">Collision collision</span>)</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter</span>(<span class="hljs-params">Collider other</span>)</span>&#123;<br>  <span class="hljs-comment">//other就是触发的collider</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerStay</span>(<span class="hljs-params">Collider other</span>)</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerExit</span>(<span class="hljs-params">Collider other</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li>
<li><code>Material</code>: 使用<code>Physical Material</code>文件, 创建<code>Friction</code>摩擦力<ul>
<li><code>Bounciness</code>: 弹力, 1没有能量损失</li>
<li><code>Xx Combine</code>: 两个摩擦GO时如何计算</li>
</ul>
</li>
</ul>
<h2 id="铰链关节-弹簧关节和固定关节-Hinge-Joint-Spring-Jonit和Fixed-Joint组件"><a href="#铰链关节-弹簧关节和固定关节-Hinge-Joint-Spring-Jonit和Fixed-Joint组件" class="headerlink" title="铰链关节,弹簧关节和固定关节: Hinge Joint,Spring Jonit和Fixed Joint组件"></a>铰链关节,弹簧关节和固定关节: <code>Hinge Joint</code>,<code>Spring Jonit</code>和<code>Fixed Joint</code>组件</h2><ul>
<li><code>Anchor</code>: 轴原点</li>
<li><code>Axis</code>: 轴向量</li>
</ul>
<h2 id="射线检测"><a href="#射线检测" class="headerlink" title="射线检测"></a>射线检测</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>&#123;<br>  <span class="hljs-keyword">if</span>(Input.GetMouseButtonDown(<span class="hljs-number">0</span>))&#123;<br>    <span class="hljs-comment">//从Camera发射一个射线</span><br>    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);<br>    <span class="hljs-comment">// 声明一个RaycastHit对象接受hit结果</span><br>    RaycastHit hit;<br>    <span class="hljs-comment">//使用Physics.Raycast函数发射ray, 并将发射结果保存到引用参数hit中</span><br>    <span class="hljs-keyword">if</span>(Physics.Raycast(ray,<span class="hljs-keyword">out</span> hit))&#123;<br>      <span class="hljs-comment">//打印在3Dunity中与射线相撞的第一个rigidbody的撞击坐标</span><br>      Debug.log(hit.point);<br>    &#125;<br><br>    <span class="hljs-comment">//如果检测多个rigidbody相撞目标,需要实例化RaycastHit[]数组接收, 使用Physics.RaycastAll(Ray ray)多次检测</span><br>    RaycastHit[] hit = Physics.RaycastAll(ray,[<span class="hljs-built_in">int</span> 检测距离],[<span class="hljs-built_in">int</span> 检测图层],[...]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="粒子系统-Partical-System组件"><a href="#粒子系统-Partical-System组件" class="headerlink" title="粒子系统: Partical System组件"></a>粒子系统: <code>Partical System</code>组件</h2><ul>
<li><code>Prewarm</code>: 从stop开始时, 是否从0逐渐展开</li>
<li><code>Start Lifetime</code>: 粒子在空中的存在时间</li>
<li><code>3D Start Size/Rotation</code>: 开启后转换为3D粒子;默认为面向Camera的平面粒子</li>
<li><code>Flip Rotation</code>: 水平翻转旋转</li>
<li><code>Gravity Modifier</code>: 粒子重力效果<ul>
<li><code>Constant</code>: 固定值,[-1上重力,1下重力]</li>
<li><code>Curve</code>: 受力曲线</li>
</ul>
</li>
<li><code>Simulation Space</code>: 生成的粒子是否随GO移动而移动;Local随,World不随,Custom绑定其他GO</li>
</ul>
<h2 id="线段和拖尾-LineRenderer和TrailRenderer组件"><a href="#线段和拖尾-LineRenderer和TrailRenderer组件" class="headerlink" title="线段和拖尾: LineRenderer和TrailRenderer组件"></a>线段和拖尾: <code>LineRenderer</code>和<code>TrailRenderer</code>组件</h2><h2 id="旧动画-Animation组件"><a href="#旧动画-Animation组件" class="headerlink" title="旧动画: Animation组件"></a>旧动画: <code>Animation</code>组件</h2><ul>
<li><code>Culling Typ</code>: 是否一直播放动画</li>
<li>动画窗体: ctrl+6</li>
<li>使用类似AudioSource: Play(),animation clip</li>
</ul>
<h2 id="新动画-Animator组件"><a href="#新动画-Animator组件" class="headerlink" title="新动画: Animator组件"></a>新动画: <code>Animator</code>组件</h2><ul>
<li><code>Controller</code>: 由<code>AnimatorController.controller</code>资源文件控制</li>
<li><code>Culling Mode</code>: <code>Cull Update Transforms</code>表示不在镜头时暂停渲染, <code>Cull Completely</code>表示不在镜头时完全停止</li>
<li>在Window-Animation中创建不同的动画资源<code>.anim</code>文件, 在Window-Animator中作为不同的动画状态<code>State</code>进行管理</li>
<li><code>.controller</code>文件包含了三方面内容: <ul>
<li>对<code>.anim</code>文件的引用</li>
<li>对<code>.anim</code>文件的设置</li>
<li><code>.anim</code>文件之间的相互连接关系</li>
</ul>
</li>
</ul>
<h3 id="动画的构成-anim文件"><a href="#动画的构成-anim文件" class="headerlink" title="动画的构成: anim文件"></a>动画的构成: <code>anim</code>文件</h3><ul>
<li><code>Rig</code> - <code>Animation Type</code>: 动画类型<ul>
<li>无: 不包含动画</li>
<li><code>Legacy</code>旧版: 只能用<code>Animation</code>旧版动画组件</li>
<li><code>Generic</code>泛型: 新版动画, 各种非人动画</li>
<li><code>Humanoid</code>人型: 新版动画, 用于人</li>
</ul>
</li>
<li><code>Rig</code> - <code>Avatar</code>骨骼: 从模型或从其他地方</li>
<li><code>Animation</code>: 对动画Clip进行细操<ul>
<li><code>Loop Match</code>: 首位帧是否相似</li>
<li><code>Bake Into Pose</code>: 烘焙特定方向的位移, 避免在动画过程中发生位移</li>
<li><code>Curves</code>曲线: 随动画播放时间的函数曲线, 其值同步在<code>animator</code>的同名<code>parameters</code>中</li>
<li><code>Events</code>事件: 在动画的某一帧调用函数(如脚步踏地时发出脚步声)</li>
</ul>
</li>
<li><code>Blend Tree</code> in AnimatorWindowContext: 混合动画(如走和跑的混合)<ul>
<li><code>Blend Type</code>混合模式: 由几个变量控制混合动画的计算, 变量在<code>animator</code>的同名<code>parameters</code>中</li>
<li><code>Motion</code>: 选择混合的动画</li>
<li><code>Automate Thresholds</code>: 是否默认各个<code>Motion</code>的取值范围</li>
</ul>
</li>
<li><code>Sub-State Machine</code> in AnimatorWindowContext子状态机: 不同的动画状态的分组归类<ul>
<li>如拿枪到一个子状态中, 换刀到另一个子状态中</li>
</ul>
</li>
<li><code>Base Layer</code>: 动画状态图层<ul>
<li><code>Weight</code>:权重; <code>Mask</code>: Avatar骨骼遮罩; <code>IK</code>: 反向动力学效果;</li>
<li>不使用<code>Mask</code>可以通过控制 <code>Weight</code>获得同<code>Blend Tree</code>一样的效果, 使用<code>Mask</code>可以精确实现不同部位动画的混合</li>
</ul>
</li>
</ul>
<h2 id="导航系统-需要在PackageManagement中安装AI-Navigation组件"><a href="#导航系统-需要在PackageManagement中安装AI-Navigation组件" class="headerlink" title="导航系统(需要在PackageManagement中安装AI Navigation组件)"></a>导航系统(需要在PackageManagement中安装<code>AI Navigation</code>组件)</h2><h3 id="1-静态障碍物"><a href="#1-静态障碍物" class="headerlink" title="1.静态障碍物"></a>1.静态障碍物</h3><ul>
<li>首先将道路GO勾选为<code>Navigation Static</code>, 然后在选择Window - AI - Navigation设置烘焙; 接着将PlayerGO添加<code>NavMeshAgent</code>组件</li>
<li><code>Bake</code>: 烘焙Agent的半径, 高度, 可上最大坡度Slope, 台阶每一阶步高, 可掉落的高度, 可跳跃的距离. (可以添加多个Agent, 作为高矮胖瘦不同的人)</li>
<li><code>掉落高度</code>和<code>跳跃距离</code>是通过生成<code>OffMeshLinks</code>实现, 需要勾选需要生成links的障碍物GO的<code>Object</code> - <code>Generate OffMeshLinks</code></li>
<li><code>Area</code>: 不同区域的成本消耗设置, 在<code>Object</code> - <code>Navigation Area</code>中更改</li>
<li><code>Nav Mesh Agent</code>组件:<ul>
<li><code>Steering</code>: 位移相关<ul>
<li><code>Acceleration</code>: 加速度</li>
</ul>
</li>
<li><code>Obstacle Avoidance</code> - <code>Priority</code>: 一个路口多个Agent待通过时的优先级</li>
<li><code>Area Mask</code>区域遮罩: 特定区域永远不可通过, 用于针对不同Agent设定不同的禁止区域</li>
</ul>
</li>
<li>代码实现:<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//前面获取代理组件</span><br><span class="hljs-keyword">using</span> UnityEngine.AI;<br>NavMeshAgent agent = GetComponent&lt;NavMeshAgent&gt;();<br><br><span class="hljs-comment">//在Update方法中逐帧更新:</span><br><span class="hljs-keyword">if</span>(GetMouseButtonDown(<span class="hljs-number">0</span>))&#123;<br>  Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);<br>  RaycastHit hit;<br>  <span class="hljs-keyword">if</span>(Physics.Raycast(ray, <span class="hljs-keyword">out</span> hit)) <span class="hljs-comment">//从屏幕点击到3D位置坐标</span><br>  &#123; <br>    agent.SetDestination(<span class="hljs-keyword">new</span> Vector3(hit.point)); <span class="hljs-comment">//将坐标设为destination</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-动态障碍物"><a href="#2-动态障碍物" class="headerlink" title="2.动态障碍物"></a>2.动态障碍物</h3><ul>
<li>将特定的某些GO取消勾选<code>Navigation Static</code>, 并添加<code>NavMeshObstacle</code>组件<ul>
<li><code>Carve</code>切割: 勾选后会根据该GO的位移重新烘焙原有的静态障碍道路<ul>
<li><code>Move Threshold</code>移动阈值: 最小移动多远时开始rebake</li>
<li><code>Time to Stationary</code>静止时间: 移动阈值后经过多少秒开始rebake</li>
<li><code>Carve Only Stationary</code>仅在静止时切割: 取消后会随着位移即时rebake, 性能消耗较大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-点对点定点传送-Off-Mesh-Link组件"><a href="#3-点对点定点传送-Off-Mesh-Link组件" class="headerlink" title="3.点对点定点传送: Off Mesh Link组件"></a>3.点对点定点传送: <code>Off Mesh Link</code>组件</h3><ul>
<li><code>Auto Update Position</code>: 当GO位置改变时, 即时更新<code>Link</code>; 如果位置不会改变就取消,以降低能耗</li>
</ul>
<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul>
<li><code>UI</code>由<code>Canvas</code>和<code>EventSystem</code>两个GO组成, <code>Canvas</code>为所有UI控件GO的父物体</li>
<li><code>Canvas</code>组件:<ul>
<li><code>Render Mode</code>: <ul>
<li><code>OverLay</code>: 永远在最上层</li>
<li><code>Camera</code>: 可被其他GO覆盖</li>
<li><code>World Space</code>: 在3D世界中的一层平面, 可旋转</li>
</ul>
</li>
<li><code>Sort Order</code>: 多个<code>Canvas</code>时的渲染优先级</li>
</ul>
</li>
<li><code>Image</code>组件:<br><code>Raycast Target</code>: 是否接收射线投射<br><code>Anchors</code>: 缩放参照锚点<br><code>Pivot</code>: 图片的轴心, 图片的旋转缩放坐标都是由轴心控制</li>
<li>字体: 新版更清晰, 富文本更多<ul>
<li><code>Color Gradient</code>: 颜色渐变</li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Unity/" class="category-chain-item">Unity</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Unity/" class="print-no-link">#Unity</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/02/10/%E8%BF%87%E9%87%8F%E8%A1%A5%E5%85%85%E7%BB%B4%E7%94%9F%E7%B4%A0B%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/" title="过量补充维生素B的副作用">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">过量补充维生素B的副作用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/02/06/hello-world/" title="Hello World">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://cdn.staticfile.org/waline/2.15.5/waline.min.css')
      Fluid.utils.createScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://tvwzrcmn.api.lncldglobal.com  ","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":100,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
